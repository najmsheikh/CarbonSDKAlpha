<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Carbon Game Development Toolkit: cgScene Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Carbon Game Development Toolkit
   &#160;<span id="projectnumber">Alpha Pre-release v0.8.16</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcg_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classcg_scene-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cgScene Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main class responsible for loading and managing an individual scene. A scene is essentially a collection of objects which might for instance make up the exterior world (containing a full blown landscape etc.) or the interior of a building.  
 <a href="classcg_scene.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cg_scene_8h_source.html">cgScene.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cgScene:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcg_scene.png" usemap="#cgScene_map" alt=""/>
  <map id="cgScene_map" name="cgScene_map">
<area href="classcg_reference.html" title="Base class which provides standardized reference counting behaviors in addition to recording informat..." alt="cgReference" shape="rect" coords="0,112,236,136"/>
<area href="classcg_physics_world_event_listener.html" title="Abstract interface class from which other classes can derive in order to recieve messages whenever ph..." alt="cgPhysicsWorldEventListener" shape="rect" coords="246,112,482,136"/>
<area href="classcg_event_dispatcher.html" title="Base class from which other classes may derive if they want to be able to have listeners register wit..." alt="cgEventDispatcher" shape="rect" coords="0,56,236,80"/>
<area href="classcg_event_listener.html" title="Abstract interface class from which other listener classes can derive in order to recieve messages wh..." alt="cgEventListener" shape="rect" coords="246,56,482,80"/>
<area href="classcg_script_interop_1_1_disposable_script_object.html" title="Base class from which objects should be derived if they need to be passed to a script by reference as..." alt="cgScriptInterop::DisposableScriptObject" shape="rect" coords="0,0,236,24"/>
<area href="classcg_script_interop_1_1_disposable_script_object.html" title="Base class from which objects should be derived if they need to be passed to a script by reference as..." alt="cgScriptInterop::DisposableScriptObject" shape="rect" coords="246,0,482,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcg_scene_1_1_ray_cast_filter_data.html">RayCastFilterData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcg_scene_1_1_update_bucket.html">UpdateBucket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3acdeafba075b1d94714c840f3373518"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3acdeafba075b1d94714c840f3373518">cgScene</a> (<a class="el" href="classcg_world.html">cgWorld</a> *world, const <a class="el" href="classcg_scene_descriptor.html">cgSceneDescriptor</a> *descriptor)</td></tr>
<tr class="memdesc:a3acdeafba075b1d94714c840f3373518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor. <a href="#a3acdeafba075b1d94714c840f3373518"></a><br/></td></tr>
<tr class="separator:a3acdeafba075b1d94714c840f3373518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9889a2e0985e50b30a22f582395f656"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ac9889a2e0985e50b30a22f582395f656">~cgScene</a> ()</td></tr>
<tr class="memdesc:ac9889a2e0985e50b30a22f582395f656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor. Falls through to the class' <a class="el" href="classcg_scene.html#a5623458a9abe0ddbbf65adf892cd8e87" title="Release any memory, references or resources allocated by this object. ">dispose()</a> method.  <a href="#ac9889a2e0985e50b30a22f582395f656"></a><br/></td></tr>
<tr class="separator:ac9889a2e0985e50b30a22f582395f656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab4a89e68d1704f3feef14d1231324b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcg_string.html">cgString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a1ab4a89e68d1704f3feef14d1231324b">getName</a> () const </td></tr>
<tr class="memdesc:a1ab4a89e68d1704f3feef14d1231324b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply retrieve the name of this loaded scene.  <a href="#a1ab4a89e68d1704f3feef14d1231324b"></a><br/></td></tr>
<tr class="separator:a1ab4a89e68d1704f3feef14d1231324b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd0ea4820b8c4f148350d4346f68a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#addd0ea4820b8c4f148350d4346f68a03">getSceneId</a> () const </td></tr>
<tr class="memdesc:addd0ea4820b8c4f148350d4346f68a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the unique integer identifier associated with this scene.  <a href="#addd0ea4820b8c4f148350d4346f68a03"></a><br/></td></tr>
<tr class="separator:addd0ea4820b8c4f148350d4346f68a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36302e3a7d0da535f0456581d6e3e7d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_world.html">cgWorld</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a36302e3a7d0da535f0456581d6e3e7d4">getParentWorld</a> () const </td></tr>
<tr class="memdesc:a36302e3a7d0da535f0456581d6e3e7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the world to which this scene belongs.  <a href="#a36302e3a7d0da535f0456581d6e3e7d4"></a><br/></td></tr>
<tr class="separator:a36302e3a7d0da535f0456581d6e3e7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc6854e89d05e9536685e2a983ce607"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#acfc6854e89d05e9536685e2a983ce607">load</a> ()</td></tr>
<tr class="memdesc:acfc6854e89d05e9536685e2a983ce607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the scene and begin the loading process. <a href="#acfc6854e89d05e9536685e2a983ce607"></a><br/></td></tr>
<tr class="separator:acfc6854e89d05e9536685e2a983ce607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5193f6e7b6385274925d5a79be4a6fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ae5193f6e7b6385274925d5a79be4a6fc">reload</a> ()</td></tr>
<tr class="memdesc:ae5193f6e7b6385274925d5a79be4a6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload and then immediately reload the scene data. <a href="#ae5193f6e7b6385274925d5a79be4a6fc"></a><br/></td></tr>
<tr class="separator:ae5193f6e7b6385274925d5a79be4a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97c8f36abd93191312fae0db1fa27e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ad97c8f36abd93191312fae0db1fa27e2">unload</a> ()</td></tr>
<tr class="memdesc:ad97c8f36abd93191312fae0db1fa27e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload this scene from the parent manager with a convenient method.  <a href="#ad97c8f36abd93191312fae0db1fa27e2"></a><br/></td></tr>
<tr class="separator:ad97c8f36abd93191312fae0db1fa27e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d04893e47c784c349913754a1a203c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a81d04893e47c784c349913754a1a203c">isLoading</a> () const </td></tr>
<tr class="memdesc:a81d04893e47c784c349913754a1a203c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the scene is currently in the process of loading.  <a href="#a81d04893e47c784c349913754a1a203c"></a><br/></td></tr>
<tr class="separator:a81d04893e47c784c349913754a1a203c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabda8988b0896dcdc186a68aa3f2974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#acabda8988b0896dcdc186a68aa3f2974">getRenderClassId</a> (const <a class="el" href="classcg_string.html">cgString</a> &amp;className) const </td></tr>
<tr class="memdesc:acabda8988b0896dcdc186a68aa3f2974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the integer identifier associated with the specified user defined render class name string.  <a href="#acabda8988b0896dcdc186a68aa3f2974"></a><br/></td></tr>
<tr class="separator:acabda8988b0896dcdc186a68aa3f2974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c2561766b6aeb25f9da41c9bf2d9e9"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
cgFilterExpression::IdentifierArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aa0c2561766b6aeb25f9da41c9bf2d9e9">getMaterialPropertyIdentifiers</a> () const </td></tr>
<tr class="memdesc:aa0c2561766b6aeb25f9da41c9bf2d9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the pre-constructed list of identifiers (compatible with <a class="el" href="classcg_filter_expression.html" title="A utility class that allows for complex (string based) boolean style expressions to be supplied that ...">cgFilterExpression</a>) for the various user defined material properties types.  <a href="#aa0c2561766b6aeb25f9da41c9bf2d9e9"></a><br/></td></tr>
<tr class="separator:aa0c2561766b6aeb25f9da41c9bf2d9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215fc59e2b9a255d6fdc9c7197717e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a215fc59e2b9a255d6fdc9c7197717e76">suppressEvents</a> (bool suppress)</td></tr>
<tr class="memdesc:a215fc59e2b9a255d6fdc9c7197717e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to enable or disable the dispatching of events that normally takes place when actions are performed on the scene such as creating or deleting objects, adding scene elements, etc. All events supported by '<a class="el" href="classcg_scene_event_listener.html" title="Abstract interface class from which other classes can derive in order to recieve messages whenever sc...">cgSceneEventListener</a>' will be suppressed when enabled.  <a href="#a215fc59e2b9a255d6fdc9c7197717e76"></a><br/></td></tr>
<tr class="separator:a215fc59e2b9a255d6fdc9c7197717e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2ea334fd5172476f520ad11e063941"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#afe2ea334fd5172476f520ad11e063941">isEventSuppressionEnabled</a> () const </td></tr>
<tr class="memdesc:afe2ea334fd5172476f520ad11e063941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not standard scene events are currently being suppressed.  <a href="#afe2ea334fd5172476f520ad11e063941"></a><br/></td></tr>
<tr class="separator:afe2ea334fd5172476f520ad11e063941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5577c13664a2ff9adfd9ba4e420df0bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a5577c13664a2ff9adfd9ba4e420df0bd">clear</a> ()</td></tr>
<tr class="memdesc:a5577c13664a2ff9adfd9ba4e420df0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completely destroy and remove all resident scene nodes and elements leaving a completely empty scene.  <a href="#a5577c13664a2ff9adfd9ba4e420df0bd"></a><br/></td></tr>
<tr class="separator:a5577c13664a2ff9adfd9ba4e420df0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2f7b31f998d700b6aedd1930b1106b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#afc2f7b31f998d700b6aedd1930b1106b">enableUpdates</a> (bool enabled)</td></tr>
<tr class="memdesc:afc2f7b31f998d700b6aedd1930b1106b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state which determines whether scene objects will automatically receive calls to their 'update' method during scene update processing.  <a href="#afc2f7b31f998d700b6aedd1930b1106b"></a><br/></td></tr>
<tr class="separator:afc2f7b31f998d700b6aedd1930b1106b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9760ffe743dfd688ed75a85bd5fe5fa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a9760ffe743dfd688ed75a85bd5fe5fa4">isUpdatingEnabled</a> () const </td></tr>
<tr class="memdesc:a9760ffe743dfd688ed75a85bd5fe5fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state which determines whether scene objects will automatically receive calls to their 'update' method during scene update processing.  <a href="#a9760ffe743dfd688ed75a85bd5fe5fa4"></a><br/></td></tr>
<tr class="separator:a9760ffe743dfd688ed75a85bd5fe5fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a7f0d42d0e657229141cb6a2f62e9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ad5a7f0d42d0e657229141cb6a2f62e9a">isUpdating</a> () const </td></tr>
<tr class="memdesc:ad5a7f0d42d0e657229141cb6a2f62e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the scene currently within its main update process?  <a href="#ad5a7f0d42d0e657229141cb6a2f62e9a"></a><br/></td></tr>
<tr class="separator:ad5a7f0d42d0e657229141cb6a2f62e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e8738cf21d7fa8b3c0a3c3d6d9d0f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a87e8738cf21d7fa8b3c0a3c3d6d9d0f5">update</a> ()</td></tr>
<tr class="memdesc:a87e8738cf21d7fa8b3c0a3c3d6d9d0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the scene to perform its update pass prior to rendering.  <a href="#a87e8738cf21d7fa8b3c0a3c3d6d9d0f5"></a><br/></td></tr>
<tr class="separator:a87e8738cf21d7fa8b3c0a3c3d6d9d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54470b68bfc3b6ec091e2fda7cbd38d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aa54470b68bfc3b6ec091e2fda7cbd38d">queueNodeUpdates</a> (<a class="el" href="classcg_object_node.html">cgObjectNode</a> *node)</td></tr>
<tr class="memdesc:aa54470b68bfc3b6ec091e2fda7cbd38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called internally when an object node has been updated in order to queue that node for additional processing in cases where certain update processes need to be deferred until a later time. An example might be the deferral of child transform updates until all nodes in a hierarchy have been processed (such as during the animation of a character's full bone hierarchy).  <a href="#aa54470b68bfc3b6ec091e2fda7cbd38d"></a><br/></td></tr>
<tr class="separator:aa54470b68bfc3b6ec091e2fda7cbd38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50de8701184c05339e365df634ce5d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ae50de8701184c05339e365df634ce5d2">resolvedNodeUpdates</a> (<a class="el" href="classcg_object_node.html">cgObjectNode</a> *node)</td></tr>
<tr class="memdesc:ae50de8701184c05339e365df634ce5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specified node's pending updates have been resolved and it can be removed from the pending update set.  <a href="#ae50de8701184c05339e365df634ce5d2"></a><br/></td></tr>
<tr class="separator:ae50de8701184c05339e365df634ce5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a82dade080c4680cbfc6db5bc8d575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a78a82dade080c4680cbfc6db5bc8d575">resolvePendingUpdates</a> ()</td></tr>
<tr class="memdesc:a78a82dade080c4680cbfc6db5bc8d575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all pending node updates that opted to defer the computation of certain information until the entire update process was complete.  <a href="#a78a82dade080c4680cbfc6db5bc8d575"></a><br/></td></tr>
<tr class="separator:a78a82dade080c4680cbfc6db5bc8d575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcc82d6ef3896c2b5c566b7c41eb835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3bcc82d6ef3896c2b5c566b7c41eb835">enableDynamics</a> (bool enabled)</td></tr>
<tr class="memdesc:a3bcc82d6ef3896c2b5c566b7c41eb835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state which determines whether scene dynamics processing (physics updates) are currently enabled.  <a href="#a3bcc82d6ef3896c2b5c566b7c41eb835"></a><br/></td></tr>
<tr class="separator:a3bcc82d6ef3896c2b5c566b7c41eb835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d56d8312480d84f6c12ffdf731cc7fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0d56d8312480d84f6c12ffdf731cc7fd">isDynamicsEnabled</a> () const </td></tr>
<tr class="memdesc:a0d56d8312480d84f6c12ffdf731cc7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state which determines whether scene dynamics processing (physics updates) are currently enabled.  <a href="#a0d56d8312480d84f6c12ffdf731cc7fd"></a><br/></td></tr>
<tr class="separator:a0d56d8312480d84f6c12ffdf731cc7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef75fb094862a793fafc75e7c91cd9bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aef75fb094862a793fafc75e7c91cd9bd">createObjectNode</a> (bool internalNode, const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;objectTypeIdentifier, bool autoAssignName)</td></tr>
<tr class="memdesc:aef75fb094862a793fafc75e7c91cd9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node of the specified type and add it to the scene's node database.  <a href="#aef75fb094862a793fafc75e7c91cd9bd"></a><br/></td></tr>
<tr class="separator:aef75fb094862a793fafc75e7c91cd9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd88ba85b0a18b3148d8cd07c4bc9cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#acd88ba85b0a18b3148d8cd07c4bc9cd3">createObjectNode</a> (bool internalNode, const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;objectTypeIdentifier, bool autoAssignName, <a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a> cloneMethod, <a class="el" href="classcg_object_node.html">cgObjectNode</a> *nodeInit, const <a class="el" href="classcg_transform.html">cgTransform</a> &amp;initTransform)</td></tr>
<tr class="memdesc:acd88ba85b0a18b3148d8cd07c4bc9cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node of the specified type and add it to the scene's node database. The new node should represent a clone of the specified initializing node, cloned using the provided method.  <a href="#acd88ba85b0a18b3148d8cd07c4bc9cd3"></a><br/></td></tr>
<tr class="separator:acd88ba85b0a18b3148d8cd07c4bc9cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d0cf8ea3fa3eb7e309e50299a9568d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a37d0cf8ea3fa3eb7e309e50299a9568d">loadObjectNode</a> (<a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> referenceId, <a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a> cloneMethod, bool loadChildren)</td></tr>
<tr class="memdesc:a37d0cf8ea3fa3eb7e309e50299a9568d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recreate a previously existing node, loading it from the database based on the specified reference identifier. The node did not originally have to belong to this scene, and can optionally be cloned into a new node (with a new internal identifier) if required. This is essentially the primary method by which the application 'spawn in' new entities.  <a href="#a37d0cf8ea3fa3eb7e309e50299a9568d"></a><br/></td></tr>
<tr class="separator:a37d0cf8ea3fa3eb7e309e50299a9568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ce25b0fb23fc2b11ceb309469387d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a6c6ce25b0fb23fc2b11ceb309469387d">unloadObjectNode</a> (<a class="el" href="classcg_object_node.html">cgObjectNode</a> *node)</td></tr>
<tr class="memdesc:a6c6ce25b0fb23fc2b11ceb309469387d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call in order to remove the specified node from the in-memory scene but /not/ from the scene database.  <a href="#a6c6ce25b0fb23fc2b11ceb309469387d"></a><br/></td></tr>
<tr class="separator:a6c6ce25b0fb23fc2b11ceb309469387d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fa0e8a5b59886e64b41b9422d72a7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a71fa0e8a5b59886e64b41b9422d72a7d">unloadObjectNode</a> (<a class="el" href="classcg_object_node.html">cgObjectNode</a> *node, bool unloadChildren)</td></tr>
<tr class="memdesc:a71fa0e8a5b59886e64b41b9422d72a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call in order to remove the specified node from the in-memory scene but /not/ from the scene database.  <a href="#a71fa0e8a5b59886e64b41b9422d72a7d"></a><br/></td></tr>
<tr class="separator:a71fa0e8a5b59886e64b41b9422d72a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a049b7080740f6fa8d64c2f039de070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a2a049b7080740f6fa8d64c2f039de070">unloadObjectNodes</a> (cgObjectNodeMap &amp;nodes)</td></tr>
<tr class="memdesc:a2a049b7080740f6fa8d64c2f039de070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call in order to remove a whole list of nodes from the in-memory scene in one go, but /not/ from the scene database.  <a href="#a2a049b7080740f6fa8d64c2f039de070"></a><br/></td></tr>
<tr class="separator:a2a049b7080740f6fa8d64c2f039de070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff0cd76db156903a639ac31b7293446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_scene_element.html">cgSceneElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a7ff0cd76db156903a639ac31b7293446">createSceneElement</a> (bool internalElement, const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;elementTypeIdentifier)</td></tr>
<tr class="memdesc:a7ff0cd76db156903a639ac31b7293446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new scene element of the specified type and add it to the scene's child element database.  <a href="#a7ff0cd76db156903a639ac31b7293446"></a><br/></td></tr>
<tr class="separator:a7ff0cd76db156903a639ac31b7293446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee1cad5d922ade8be2cf5df2f9009cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a2ee1cad5d922ade8be2cf5df2f9009cd">unloadSceneElement</a> (<a class="el" href="classcg_scene_element.html">cgSceneElement</a> *element)</td></tr>
<tr class="memdesc:a2ee1cad5d922ade8be2cf5df2f9009cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call in order to remove the scene element from the in-memory scene but /not/ from the scene database.  <a href="#a2ee1cad5d922ade8be2cf5df2f9009cd"></a><br/></td></tr>
<tr class="separator:a2ee1cad5d922ade8be2cf5df2f9009cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947a1aff7a1a0fb85f64ba3a374e24b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a947a1aff7a1a0fb85f64ba3a374e24b1">addRootNode</a> (<a class="el" href="classcg_object_node.html">cgObjectNode</a> *node)</td></tr>
<tr class="memdesc:a947a1aff7a1a0fb85f64ba3a374e24b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified object node to the scene as a root node. This is simply a list that outlines all of the nodes that exist at a root level in the hierarchy.  <a href="#a947a1aff7a1a0fb85f64ba3a374e24b1"></a><br/></td></tr>
<tr class="separator:a947a1aff7a1a0fb85f64ba3a374e24b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d24a80fa301753b0c93b91f8211a58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a54d24a80fa301753b0c93b91f8211a58">removeRootNode</a> (<a class="el" href="classcg_object_node.html">cgObjectNode</a> *node)</td></tr>
<tr class="memdesc:a54d24a80fa301753b0c93b91f8211a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified node from the scene's root node list.  <a href="#a54d24a80fa301753b0c93b91f8211a58"></a><br/></td></tr>
<tr class="separator:a54d24a80fa301753b0c93b91f8211a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729c2c060a461c158889a07e1fd9b0f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a729c2c060a461c158889a07e1fd9b0f4">getObjectNodeById</a> (<a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> referenceId) const </td></tr>
<tr class="memdesc:a729c2c060a461c158889a07e1fd9b0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the object node with the specified reference identifier if it exists within the database of currently loaded (or created) scene objects.  <a href="#a729c2c060a461c158889a07e1fd9b0f4"></a><br/></td></tr>
<tr class="separator:a729c2c060a461c158889a07e1fd9b0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc90e81d9315338852772c007421a65d"><td class="memItemLeft" align="right" valign="top">cgObjectNodeMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#abc90e81d9315338852772c007421a65d">getObjectNodes</a> ()</td></tr>
<tr class="memdesc:abc90e81d9315338852772c007421a65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a complete list of all scene object nodes.  <a href="#abc90e81d9315338852772c007421a65d"></a><br/></td></tr>
<tr class="separator:abc90e81d9315338852772c007421a65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7fe1f02051b74108ede9da028f865c"><td class="memItemLeft" align="right" valign="top">const cgObjectNodeMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a6e7fe1f02051b74108ede9da028f865c">getObjectNodes</a> () const </td></tr>
<tr class="memdesc:a6e7fe1f02051b74108ede9da028f865c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a complete list of all scene object nodes.  <a href="#a6e7fe1f02051b74108ede9da028f865c"></a><br/></td></tr>
<tr class="separator:a6e7fe1f02051b74108ede9da028f865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f3f22becb17a225bb4ab754d33139d"><td class="memItemLeft" align="right" valign="top">cgObjectNodeMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a87f3f22becb17a225bb4ab754d33139d">getRootObjectNodes</a> ()</td></tr>
<tr class="memdesc:a87f3f22becb17a225bb4ab754d33139d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a list of all scene object nodes that exist at the root level of the node hierarchy (those with no parent node).  <a href="#a87f3f22becb17a225bb4ab754d33139d"></a><br/></td></tr>
<tr class="separator:a87f3f22becb17a225bb4ab754d33139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c271ab15294ccb8f6252505df20725"><td class="memItemLeft" align="right" valign="top">const cgObjectNodeMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a92c271ab15294ccb8f6252505df20725">getRootObjectNodes</a> () const </td></tr>
<tr class="memdesc:a92c271ab15294ccb8f6252505df20725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a list of all scene object nodes that exist at the root level of the node hierarchy (those with no parent node).  <a href="#a92c271ab15294ccb8f6252505df20725"></a><br/></td></tr>
<tr class="separator:a92c271ab15294ccb8f6252505df20725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1fdd6fc3b7f67dba5d5c85ca8e72a1"><td class="memItemLeft" align="right" valign="top">const cgSceneCellMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ade1fdd6fc3b7f67dba5d5c85ca8e72a1">getSceneCells</a> () const </td></tr>
<tr class="memdesc:ade1fdd6fc3b7f67dba5d5c85ca8e72a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a complete list of all allocated scene cells.  <a href="#ade1fdd6fc3b7f67dba5d5c85ca8e72a1"></a><br/></td></tr>
<tr class="separator:ade1fdd6fc3b7f67dba5d5c85ca8e72a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801c32dfd1ba671339893cf4e0a782fc"><td class="memItemLeft" align="right" valign="top">const cgSceneElementArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a801c32dfd1ba671339893cf4e0a782fc">getSceneElements</a> () const </td></tr>
<tr class="memdesc:a801c32dfd1ba671339893cf4e0a782fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a complete list of all allocated scene elements.  <a href="#a801c32dfd1ba671339893cf4e0a782fc"></a><br/></td></tr>
<tr class="separator:a801c32dfd1ba671339893cf4e0a782fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf533f4273b254968656d6176cb50f0a"><td class="memItemLeft" align="right" valign="top">const cgSceneElementArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#abf533f4273b254968656d6176cb50f0a">getSceneElementsByType</a> (const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;type) const </td></tr>
<tr class="memdesc:abf533f4273b254968656d6176cb50f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a list of all allocated scene elements of the specified type.  <a href="#abf533f4273b254968656d6176cb50f0a"></a><br/></td></tr>
<tr class="separator:abf533f4273b254968656d6176cb50f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d43539a431f05299caa26b5cb3ec94"><td class="memItemLeft" align="right" valign="top">const cgObjectNodeArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a19d43539a431f05299caa26b5cb3ec94">getObjectNodesByType</a> (const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;type) const </td></tr>
<tr class="memdesc:a19d43539a431f05299caa26b5cb3ec94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a list of all allocated scene object nodes of the specified type.  <a href="#a19d43539a431f05299caa26b5cb3ec94"></a><br/></td></tr>
<tr class="separator:a19d43539a431f05299caa26b5cb3ec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f9fc119b84f9b1682515eef78bf0dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a90f9fc119b84f9b1682515eef78bf0dc">getObjectNodesInBounds</a> (const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;center, <a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a> radius, cgObjectNodeArray &amp;nodesOut) const </td></tr>
<tr class="memdesc:a90f9fc119b84f9b1682515eef78bf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the specified container with references to all allocated scene object nodes that fall within the specified bounding sphere.  <a href="#a90f9fc119b84f9b1682515eef78bf0dc"></a><br/></td></tr>
<tr class="separator:a90f9fc119b84f9b1682515eef78bf0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa914740b53b80d6aa50ac2ee151c910e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aa914740b53b80d6aa50ac2ee151c910e">getObjectNodesInBounds</a> (const <a class="el" href="classcg_bounding_box.html">cgBoundingBox</a> &amp;, cgObjectNodeArray &amp;nodesOut) const </td></tr>
<tr class="memdesc:aa914740b53b80d6aa50ac2ee151c910e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the specified container with references to all allocated scene object nodes that fall within the specified bounding box.  <a href="#aa914740b53b80d6aa50ac2ee151c910e"></a><br/></td></tr>
<tr class="separator:aa914740b53b80d6aa50ac2ee151c910e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff39fa2da00c0ed422645541bfa94b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a8ff39fa2da00c0ed422645541bfa94b0">setObjectUpdateRate</a> (<a class="el" href="classcg_object_node.html">cgObjectNode</a> *node, <a class="el" href="namespacecg_update_rate.html#a0da2807d89bc281aaedc56c1edbdbd24">cgUpdateRate::Base</a> rate)</td></tr>
<tr class="memdesc:a8ff39fa2da00c0ed422645541bfa94b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each update list has a different rate that can be used in order to reduce the amount of nodes which potentially have to be updated each frame. This function simply adds the node to the relevant internal update list based on the specified rate.  <a href="#a8ff39fa2da00c0ed422645541bfa94b0"></a><br/></td></tr>
<tr class="separator:a8ff39fa2da00c0ed422645541bfa94b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb868468b53dc98f74f5b72bd73d44d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3fb868468b53dc98f74f5b72bd73d44d">addController</a> (<a class="el" href="classcg_scene_controller.html">cgSceneController</a> *controller)</td></tr>
<tr class="memdesc:a3fb868468b53dc98f74f5b72bd73d44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new scene controller that, when enabled, will be triggered in the scene's update call.  <a href="#a3fb868468b53dc98f74f5b72bd73d44d"></a><br/></td></tr>
<tr class="separator:a3fb868468b53dc98f74f5b72bd73d44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a5a4376009f481390ab72019b0f7b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a80a5a4376009f481390ab72019b0f7b8">setActiveCamera</a> (<a class="el" href="classcg_camera_node.html">cgCameraNode</a> *camera)</td></tr>
<tr class="memdesc:a80a5a4376009f481390ab72019b0f7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the currently active camera.  <a href="#a80a5a4376009f481390ab72019b0f7b8"></a><br/></td></tr>
<tr class="separator:a80a5a4376009f481390ab72019b0f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee07f72d57cf5c0a5fe8a2025ed65ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_camera_node.html">cgCameraNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0ee07f72d57cf5c0a5fe8a2025ed65ac">getActiveCamera</a> () const </td></tr>
<tr class="memdesc:a0ee07f72d57cf5c0a5fe8a2025ed65ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the currently active scene camera object.  <a href="#a0ee07f72d57cf5c0a5fe8a2025ed65ac"></a><br/></td></tr>
<tr class="separator:a0ee07f72d57cf5c0a5fe8a2025ed65ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a0873d5c3079496058c4e73da995a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_landscape.html">cgLandscape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ab3a0873d5c3079496058c4e73da995a1">importLandscape</a> (const <a class="el" href="structcg_landscape_import_params.html">cgLandscapeImportParams</a> &amp;params)</td></tr>
<tr class="memdesc:ab3a0873d5c3079496058c4e73da995a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new scene landscape based on the import parameters specified.  <a href="#ab3a0873d5c3079496058c4e73da995a1"></a><br/></td></tr>
<tr class="separator:ab3a0873d5c3079496058c4e73da995a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a2d1f3b2631b55a500afac1c8c8786"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a25a2d1f3b2631b55a500afac1c8c8786">rayCastClosest</a> (const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;from, const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;to, <a class="el" href="structcg_scene_ray_cast_contact.html">cgSceneRayCastContact</a> &amp;closestContact)</td></tr>
<tr class="memdesc:a25a2d1f3b2631b55a500afac1c8c8786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the closest intersected collidable scene objects along the specified ray.  <a href="#a25a2d1f3b2631b55a500afac1c8c8786"></a><br/></td></tr>
<tr class="separator:a25a2d1f3b2631b55a500afac1c8c8786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202dbb83e8ff3cecfd704e6dba72e320"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a202dbb83e8ff3cecfd704e6dba72e320">rayCastAll</a> (const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;from, const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;to, bool sortContacts, cgSceneRayCastContact::Array &amp;contacts)</td></tr>
<tr class="memdesc:a202dbb83e8ff3cecfd704e6dba72e320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a list of all intersected collidable scene objects along the specified ray. The list of contacts can optionally be sorted by distance with the closest intersection first.  <a href="#a202dbb83e8ff3cecfd704e6dba72e320"></a><br/></td></tr>
<tr class="separator:a202dbb83e8ff3cecfd704e6dba72e320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9127b59ef958523c24060da0fafcad16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a9127b59ef958523c24060da0fafcad16">getCellSize</a> () const </td></tr>
<tr class="memdesc:a9127b59ef958523c24060da0fafcad16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the specified size of each individual cell used for scene management.  <a href="#a9127b59ef958523c24060da0fafcad16"></a><br/></td></tr>
<tr class="separator:a9127b59ef958523c24060da0fafcad16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361cf32b0911e3dcc24fc20c9e7d2cc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a361cf32b0911e3dcc24fc20c9e7d2cc8">updateObjectOwnership</a> (<a class="el" href="classcg_object_node.html">cgObjectNode</a> *node)</td></tr>
<tr class="memdesc:a361cf32b0911e3dcc24fc20c9e7d2cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the various spatial (and scene) tree components to determine if it can / wants to own the specified object and optionally inserts it into the relevant cells / leaves.  <a href="#a361cf32b0911e3dcc24fc20c9e7d2cc8"></a><br/></td></tr>
<tr class="separator:a361cf32b0911e3dcc24fc20c9e7d2cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa499db21ab6e4995d2caecbe0639f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aaa499db21ab6e4995d2caecbe0639f25">computeVisibility</a> (const <a class="el" href="classcg_frustum.html">cgFrustum</a> &amp;frustum, <a class="el" href="classcg_visibility_set.html">cgVisibilitySet</a> *visibilityData)</td></tr>
<tr class="memdesc:aaa499db21ab6e4995d2caecbe0639f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the application to allow us to retrieve leaf visibility information and rendering subsets.  <a href="#aaa499db21ab6e4995d2caecbe0639f25"></a><br/></td></tr>
<tr class="separator:aaa499db21ab6e4995d2caecbe0639f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9502b6cfc1b46efa6327bbc515fe9be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_physics_world.html">cgPhysicsWorld</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ab9502b6cfc1b46efa6327bbc515fe9be">getPhysicsWorld</a> () const </td></tr>
<tr class="memdesc:ab9502b6cfc1b46efa6327bbc515fe9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the scene's internal physics simulation world.  <a href="#ab9502b6cfc1b46efa6327bbc515fe9be"></a><br/></td></tr>
<tr class="separator:ab9502b6cfc1b46efa6327bbc515fe9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d11f2b42df9f7ba230ccee05c8b87ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcg_scene_descriptor.html">cgSceneDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a2d11f2b42df9f7ba230ccee05c8b87ad">getSceneDescriptor</a> () const </td></tr>
<tr class="memdesc:a2d11f2b42df9f7ba230ccee05c8b87ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the full descriptor for the scene.  <a href="#a2d11f2b42df9f7ba230ccee05c8b87ad"></a><br/></td></tr>
<tr class="separator:a2d11f2b42df9f7ba230ccee05c8b87ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab896b542acd9c109dc8e9ff65ccad376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_render_driver.html">cgRenderDriver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ab896b542acd9c109dc8e9ff65ccad376">getRenderDriver</a> () const </td></tr>
<tr class="memdesc:ab896b542acd9c109dc8e9ff65ccad376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply retrieve the render driver through which the scene will be rendered.  <a href="#ab896b542acd9c109dc8e9ff65ccad376"></a><br/></td></tr>
<tr class="separator:ab896b542acd9c109dc8e9ff65ccad376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8ab019b6a6ed3426a812074e9b785d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_resource_manager.html">cgResourceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0c8ab019b6a6ed3426a812074e9b785d">getResourceManager</a> () const </td></tr>
<tr class="memdesc:a0c8ab019b6a6ed3426a812074e9b785d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply retrieve the resource manager that will manage the scene's resources.  <a href="#a0c8ab019b6a6ed3426a812074e9b785d"></a><br/></td></tr>
<tr class="separator:a0c8ab019b6a6ed3426a812074e9b785d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950db52f5394e9ac553a0c0ca8987ffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_landscape.html">cgLandscape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a950db52f5394e9ac553a0c0ca8987ffb">getLandscape</a> () const </td></tr>
<tr class="memdesc:a950db52f5394e9ac553a0c0ca8987ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply retrieve any landscape associated with this scene.  <a href="#a950db52f5394e9ac553a0c0ca8987ffb"></a><br/></td></tr>
<tr class="separator:a950db52f5394e9ac553a0c0ca8987ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116d1725225823fcd9b662544e62661e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_lighting_manager.html">cgLightingManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a116d1725225823fcd9b662544e62661e">getLightingManager</a> () const </td></tr>
<tr class="memdesc:a116d1725225823fcd9b662544e62661e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the scene's internal lighting manager.  <a href="#a116d1725225823fcd9b662544e62661e"></a><br/></td></tr>
<tr class="separator:a116d1725225823fcd9b662544e62661e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13faaf586002dccfdfcbf5f736a3e02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_sphere_tree.html">cgSphereTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ad13faaf586002dccfdfcbf5f736a3e02">getSceneTree</a> () const </td></tr>
<tr class="memdesc:ad13faaf586002dccfdfcbf5f736a3e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the scene's spatial hierarchy data, most commonly used for broadphase tests.  <a href="#ad13faaf586002dccfdfcbf5f736a3e02"></a><br/></td></tr>
<tr class="separator:ad13faaf586002dccfdfcbf5f736a3e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17516470b52a88a54e155be0d2843d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a17516470b52a88a54e155be0d2843d3a">render</a> ()</td></tr>
<tr class="memdesc:a17516470b52a88a54e155be0d2843d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the scene to perform the rendering of an individual scene.  <a href="#a17516470b52a88a54e155be0d2843d3a"></a><br/></td></tr>
<tr class="separator:a17516470b52a88a54e155be0d2843d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3beb59028aacb4852f9ca2f0476df16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3beb59028aacb4852f9ca2f0476df16d">sandboxRender</a> (<a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> flags, const <a class="el" href="classcg_plane.html">cgPlane</a> &amp;gridPlane)</td></tr>
<tr class="memdesc:a3beb59028aacb4852f9ca2f0476df16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow all nodes to render their 'sandbox' representation &ndash; that is the representation to be displayed within an editing environment.  <a href="#a3beb59028aacb4852f9ca2f0476df16d"></a><br/></td></tr>
<tr class="separator:a3beb59028aacb4852f9ca2f0476df16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace18bece39a1837aee9614c6a8f8c67e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ace18bece39a1837aee9614c6a8f8c67e">beginRenderPass</a> (const <a class="el" href="classcg_string.html">cgString</a> &amp;passName)</td></tr>
<tr class="memdesc:ace18bece39a1837aee9614c6a8f8c67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called in order to set up the rendering subsystem ready for the caller to take a single draw pass over the scene. Once complete, the caller should call '<a class="el" href="classcg_scene.html#a948127b5f50c1eec82400b8fd565cd0c" title="Called once the current rendering pass has been completed. ">endRenderPass()</a>'.  <a href="#ace18bece39a1837aee9614c6a8f8c67e"></a><br/></td></tr>
<tr class="separator:ace18bece39a1837aee9614c6a8f8c67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948127b5f50c1eec82400b8fd565cd0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a948127b5f50c1eec82400b8fd565cd0c">endRenderPass</a> ()</td></tr>
<tr class="memdesc:a948127b5f50c1eec82400b8fd565cd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called once the current rendering pass has been completed.  <a href="#a948127b5f50c1eec82400b8fd565cd0c"></a><br/></td></tr>
<tr class="separator:a948127b5f50c1eec82400b8fd565cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f2ac96b8c8dda25081549c68c5547b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a19f2ac96b8c8dda25081549c68c5547b">resetScene</a> ()</td></tr>
<tr class="memdesc:a19f2ac96b8c8dda25081549c68c5547b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload the transforms and cell ownership information for the nodes in the scene as they exist in the current scene database.  <a href="#a19f2ac96b8c8dda25081549c68c5547b"></a><br/></td></tr>
<tr class="separator:a19f2ac96b8c8dda25081549c68c5547b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071a1ce228c073776117c816926c1d40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a071a1ce228c073776117c816926c1d40">enableSceneWrites</a> (bool enable)</td></tr>
<tr class="memdesc:a071a1ce228c073776117c816926c1d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable the ability for nodes to serialize their transformation updates to the scene database.  <a href="#a071a1ce228c073776117c816926c1d40"></a><br/></td></tr>
<tr class="separator:a071a1ce228c073776117c816926c1d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73b5a3470cc9d76c0704ef375f3526d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#af73b5a3470cc9d76c0704ef375f3526d">isSceneWritingEnabled</a> () const </td></tr>
<tr class="memdesc:af73b5a3470cc9d76c0704ef375f3526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are nodes allowed to serialize their transformation updates to the scene database?  <a href="#af73b5a3470cc9d76c0704ef375f3526d"></a><br/></td></tr>
<tr class="separator:af73b5a3470cc9d76c0704ef375f3526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fb003ab02b4a096be22f837632150d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ac9fb003ab02b4a096be22f837632150d">setDirty</a> (bool dirty)</td></tr>
<tr class="memdesc:ac9fb003ab02b4a096be22f837632150d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene dirty status. <a href="#ac9fb003ab02b4a096be22f837632150d"></a><br/></td></tr>
<tr class="separator:ac9fb003ab02b4a096be22f837632150d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f49cf15c31ce73f18e0bec3ca3a0a7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a5f49cf15c31ce73f18e0bec3ca3a0a7c">isDirty</a> () const </td></tr>
<tr class="memdesc:a5f49cf15c31ce73f18e0bec3ca3a0a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scene dirty status. <a href="#a5f49cf15c31ce73f18e0bec3ca3a0a7c"></a><br/></td></tr>
<tr class="separator:a5f49cf15c31ce73f18e0bec3ca3a0a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a62add9c8f46aaab2d2cc9b5fa54b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_string.html">cgString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0a62add9c8f46aaab2d2cc9b5fa54b51">makeUniqueName</a> (const <a class="el" href="classcg_string.html">cgString</a> &amp;name)</td></tr>
<tr class="memdesc:a0a62add9c8f46aaab2d2cc9b5fa54b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the specified suggested name, determine if it is unique. If it is not unique, append a number to the end such that it will become unique.  <a href="#a0a62add9c8f46aaab2d2cc9b5fa54b51"></a><br/></td></tr>
<tr class="separator:a0a62add9c8f46aaab2d2cc9b5fa54b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc7fb1cf207aa60b2c3b89c40074265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_string.html">cgString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a7dc7fb1cf207aa60b2c3b89c40074265">makeUniqueName</a> (const <a class="el" href="classcg_string.html">cgString</a> &amp;name, <a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> suffixNumber)</td></tr>
<tr class="memdesc:a7dc7fb1cf207aa60b2c3b89c40074265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the specified suggested name, determine if it is unique. If it is not unique, append a number to the end such that it will become unique. Note: Specify 0xFFFFFFFF to suffixNumber to initially search for name with no appended number.  <a href="#a7dc7fb1cf207aa60b2c3b89c40074265"></a><br/></td></tr>
<tr class="separator:a7dc7fb1cf207aa60b2c3b89c40074265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d44967ed064ea7d5679709fc18cdf14"><td class="memItemLeft" align="right" valign="top">NameUsageMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a9d44967ed064ea7d5679709fc18cdf14">getNameUsage</a> ()</td></tr>
<tr class="memdesc:a9d44967ed064ea7d5679709fc18cdf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the map that contains a list of all the node names currently in use within the scene at this time.  <a href="#a9d44967ed064ea7d5679709fc18cdf14"></a><br/></td></tr>
<tr class="separator:a9d44967ed064ea7d5679709fc18cdf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4d0a2adc71d8a3674987992471c2fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecg_unit_type.html#a3cddff019459e19bbec2d48d5887ea46">cgUnitType::Base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3f4d0a2adc71d8a3674987992471c2fc">getDistanceDisplayUnits</a> () const </td></tr>
<tr class="memdesc:a3f4d0a2adc71d8a3674987992471c2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the unit type that the artist has selected for displaying distance values.  <a href="#a3f4d0a2adc71d8a3674987992471c2fc"></a><br/></td></tr>
<tr class="separator:a3f4d0a2adc71d8a3674987992471c2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42a3ea17655eace7d74879ef77d13f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ab42a3ea17655eace7d74879ef77d13f9">applySceneRescale</a> (<a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a> scale)</td></tr>
<tr class="memdesc:ab42a3ea17655eace7d74879ef77d13f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescale all elements in the scene by the desired amount at the local / data level. For instance, a light source will scale its range properties and a mesh will rescale all of its vertices.  <a href="#ab42a3ea17655eace7d74879ef77d13f9"></a><br/></td></tr>
<tr class="separator:ab42a3ea17655eace7d74879ef77d13f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6638b85b55312f2b0bc2615470a2428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aa6638b85b55312f2b0bc2615470a2428">addSceneMaterial</a> (<a class="el" href="classcg_material.html">cgMaterial</a> *material)</td></tr>
<tr class="memdesc:aa6638b85b55312f2b0bc2615470a2428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified material to the scene for ownership. This means that the material will show up in the material editor for this scene, and also ensures that the material will never be removed from the database unless it is physically removed from the scene.  <a href="#aa6638b85b55312f2b0bc2615470a2428"></a><br/></td></tr>
<tr class="separator:aa6638b85b55312f2b0bc2615470a2428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d01508b8954380cf0fbe13567ad263"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a33d01508b8954380cf0fbe13567ad263">removeSceneMaterial</a> (<a class="el" href="classcg_material.html">cgMaterial</a> *material)</td></tr>
<tr class="memdesc:a33d01508b8954380cf0fbe13567ad263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified material from the scene's material ownership list. If the scene was the last live item reference that material, and if it held the last 'soft' reference it will be deleted from the database.  <a href="#a33d01508b8954380cf0fbe13567ad263"></a><br/></td></tr>
<tr class="separator:a33d01508b8954380cf0fbe13567ad263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175ba8eb8dd86b2eae5e4a531be1a423"><td class="memItemLeft" align="right" valign="top">const SceneMaterialMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a175ba8eb8dd86b2eae5e4a531be1a423">getSceneMaterials</a> () const </td></tr>
<tr class="memdesc:a175ba8eb8dd86b2eae5e4a531be1a423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the list of all active materials associated with this scene.  <a href="#a175ba8eb8dd86b2eae5e4a531be1a423"></a><br/></td></tr>
<tr class="separator:a175ba8eb8dd86b2eae5e4a531be1a423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ea869e2896bf617ddea3b8ac90ba3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a09ea869e2896bf617ddea3b8ac90ba3b">isActiveMaterial</a> (<a class="el" href="classcg_material.html">cgMaterial</a> *material) const </td></tr>
<tr class="memdesc:a09ea869e2896bf617ddea3b8ac90ba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified material is one of this scene's active materials (those that should show up in the material editor).  <a href="#a09ea869e2896bf617ddea3b8ac90ba3b"></a><br/></td></tr>
<tr class="separator:a09ea869e2896bf617ddea3b8ac90ba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3dd67c77a2328b10260c91fedbfc6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0b3dd67c77a2328b10260c91fedbfc6b">setActiveObjectElementType</a> (const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;typeIdentifier)</td></tr>
<tr class="memdesc:a0b3dd67c77a2328b10260c91fedbfc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sandbox environment is manipulating the specified element type (i.e. object sub-element category). This property can be queried by objects and other scene elements to determine if they should be considered the 'active' element type. Set to '<a class="el" href="classcg_u_i_d.html#ae0bb84d8bdcdfad56e2d42ea7693a8c7">cgUID::Empty</a>' to disable this.  <a href="#a0b3dd67c77a2328b10260c91fedbfc6b"></a><br/></td></tr>
<tr class="separator:a0b3dd67c77a2328b10260c91fedbfc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dca6648d56aa02bea4bb991dc06074e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0dca6648d56aa02bea4bb991dc06074e">getActiveObjectElementType</a> () const </td></tr>
<tr class="memdesc:a0dca6648d56aa02bea4bb991dc06074e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique identifier of the element type / category which the application / sandbox environment considers 'active'. An identifier of <a class="el" href="classcg_u_i_d.html#ae0bb84d8bdcdfad56e2d42ea7693a8c7">cgUID::Empty</a> means that standard top level nodes are considered 'active'.  <a href="#a0dca6648d56aa02bea4bb991dc06074e"></a><br/></td></tr>
<tr class="separator:a0dca6648d56aa02bea4bb991dc06074e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864397ec7e0d1050c9a8e39dab3888d0"><td class="memItemLeft" align="right" valign="top">const SelectionSetMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a864397ec7e0d1050c9a8e39dab3888d0">getSelectionSets</a> () const </td></tr>
<tr class="memdesc:a864397ec7e0d1050c9a8e39dab3888d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a list of the currently available selection sets.  <a href="#a864397ec7e0d1050c9a8e39dab3888d0"></a><br/></td></tr>
<tr class="separator:a864397ec7e0d1050c9a8e39dab3888d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dbca6b7060acce84d664f2d5e69ecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a52dbca6b7060acce84d664f2d5e69ecb">getSelectedAABB</a> (<a class="el" href="classcg_bounding_box.html">cgBoundingBox</a> &amp;boundsOut, <a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a> growAmount)</td></tr>
<tr class="memdesc:a52dbca6b7060acce84d664f2d5e69ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a world space axis aligned bounding box for each of the currently selected nodes.  <a href="#a52dbca6b7060acce84d664f2d5e69ecb"></a><br/></td></tr>
<tr class="separator:a52dbca6b7060acce84d664f2d5e69ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739c9a4d81c38dd4ce9803288f9ade39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a739c9a4d81c38dd4ce9803288f9ade39">getSelectedPivot</a> (<a class="el" href="classcg_vector3.html">cgVector3</a> &amp;pivotOut) const </td></tr>
<tr class="memdesc:a739c9a4d81c38dd4ce9803288f9ade39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a world space point about which selected nodes should pivot during rotation for instance. If one node is select, this will be its origin, otherwise it will be the average of all selected node origins.  <a href="#a739c9a4d81c38dd4ce9803288f9ade39"></a><br/></td></tr>
<tr class="separator:a739c9a4d81c38dd4ce9803288f9ade39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb9764f7e183c2699d047c41e9f4cb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#afcb9764f7e183c2699d047c41e9f4cb4">getObjectNodesPivot</a> (const cgObjectNodeMap &amp;nodes, <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;pivotOut) const </td></tr>
<tr class="memdesc:afcb9764f7e183c2699d047c41e9f4cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a world space point about which specified nodes should pivot during rotation for instance. If one node is select, this will be its origin, otherwise it will be the average of all selected node origins.  <a href="#afcb9764f7e183c2699d047c41e9f4cb4"></a><br/></td></tr>
<tr class="separator:afcb9764f7e183c2699d047c41e9f4cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bec20e6859a81e705fcbb78fc2bef00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a6bec20e6859a81e705fcbb78fc2bef00">selectAllNodes</a> ()</td></tr>
<tr class="memdesc:a6bec20e6859a81e705fcbb78fc2bef00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply select all nodes contained in the currently open scene.  <a href="#a6bec20e6859a81e705fcbb78fc2bef00"></a><br/></td></tr>
<tr class="separator:a6bec20e6859a81e705fcbb78fc2bef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5d24ce9737158f246eec0562d802ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0a5d24ce9737158f246eec0562d802ae">selectSimilarNodes</a> (cgObjectNodeMap &amp;nodes, bool replaceSelection)</td></tr>
<tr class="memdesc:a0a5d24ce9737158f246eec0562d802ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select nodes that have types similar to the nodes specified.  <a href="#a0a5d24ce9737158f246eec0562d802ae"></a><br/></td></tr>
<tr class="separator:a0a5d24ce9737158f246eec0562d802ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f065763bacded09a41417623839aa5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a20f065763bacded09a41417623839aa5">selectNodes</a> (cgObjectNodeMap &amp;nodes, bool replaceSelection)</td></tr>
<tr class="memdesc:a20f065763bacded09a41417623839aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a specific collection of nodes.  <a href="#a20f065763bacded09a41417623839aa5"></a><br/></td></tr>
<tr class="separator:a20f065763bacded09a41417623839aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd51919b62fbe4cba72ab95a459153e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aefd51919b62fbe4cba72ab95a459153e">clearSelection</a> ()</td></tr>
<tr class="memdesc:aefd51919b62fbe4cba72ab95a459153e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply clear out the selected nodes list.  <a href="#aefd51919b62fbe4cba72ab95a459153e"></a><br/></td></tr>
<tr class="separator:aefd51919b62fbe4cba72ab95a459153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3f3d1e455e0497b348234f7d33b5df"><td class="memItemLeft" align="right" valign="top">cgObjectNodeMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3e3f3d1e455e0497b348234f7d33b5df">getSelectedNodes</a> ()</td></tr>
<tr class="memdesc:a3e3f3d1e455e0497b348234f7d33b5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a list of the currently selected nodes.  <a href="#a3e3f3d1e455e0497b348234f7d33b5df"></a><br/></td></tr>
<tr class="separator:a3e3f3d1e455e0497b348234f7d33b5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31985e0978c58fcebba9791256b4ffb2"><td class="memItemLeft" align="right" valign="top">cgObjectNodeMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a31985e0978c58fcebba9791256b4ffb2">getSelectedNodesOrdered</a> ()</td></tr>
<tr class="memdesc:a31985e0978c58fcebba9791256b4ffb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a list of the currently selected nodes in the order in which they were selected.  <a href="#a31985e0978c58fcebba9791256b4ffb2"></a><br/></td></tr>
<tr class="separator:a31985e0978c58fcebba9791256b4ffb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3180b398f52ae1d6dc7ebbd8fbff2af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3180b398f52ae1d6dc7ebbd8fbff2af2">getNextSelectionId</a> ()</td></tr>
<tr class="memdesc:a3180b398f52ae1d6dc7ebbd8fbff2af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next consecutive integer identifier that can be used to determine the order in which nodes were selected.  <a href="#a3180b398f52ae1d6dc7ebbd8fbff2af2"></a><br/></td></tr>
<tr class="separator:a3180b398f52ae1d6dc7ebbd8fbff2af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af71dd70f74e777103215663c34a29f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a4af71dd70f74e777103215663c34a29f">deleteSelected</a> ()</td></tr>
<tr class="memdesc:a4af71dd70f74e777103215663c34a29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any currently selected nodes.  <a href="#a4af71dd70f74e777103215663c34a29f"></a><br/></td></tr>
<tr class="separator:a4af71dd70f74e777103215663c34a29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99733b4ad551388cf7466ed2a11730f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a99733b4ad551388cf7466ed2a11730f6">deleteObjectNode</a> (<a class="el" href="classcg_object_node.html">cgObjectNode</a> *node)</td></tr>
<tr class="memdesc:a99733b4ad551388cf7466ed2a11730f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call in order to delete a single specified node from the scene database.  <a href="#a99733b4ad551388cf7466ed2a11730f6"></a><br/></td></tr>
<tr class="separator:a99733b4ad551388cf7466ed2a11730f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f9a7bfd285e447d0a32e4c4e547537"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a85f9a7bfd285e447d0a32e4c4e547537">deleteObjectNodes</a> (cgObjectNodeMap &amp;nodes)</td></tr>
<tr class="memdesc:a85f9a7bfd285e447d0a32e4c4e547537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call in order to delete a whole list of specified nodes from the scene database in one go.  <a href="#a85f9a7bfd285e447d0a32e4c4e547537"></a><br/></td></tr>
<tr class="separator:a85f9a7bfd285e447d0a32e4c4e547537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9172d6387a27760878c7f4d4e126d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aef9172d6387a27760878c7f4d4e126d5">deleteSceneElement</a> (<a class="el" href="classcg_scene_element.html">cgSceneElement</a> *element)</td></tr>
<tr class="memdesc:aef9172d6387a27760878c7f4d4e126d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified material from the scene's material ownership list. If the scene was the last live item reference that material, and if it held the last 'soft' reference it will be deleted from the database.  <a href="#aef9172d6387a27760878c7f4d4e126d5"></a><br/></td></tr>
<tr class="separator:aef9172d6387a27760878c7f4d4e126d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b28bfcb67a4123a5b4844e5417a2819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a6b28bfcb67a4123a5b4844e5417a2819">pickClosestNode</a> (const <a class="el" href="structcg_size.html">cgSize</a> &amp;viewportSize, const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;rayOrigin, const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;rayDirection, <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;intersectionOut)</td></tr>
<tr class="memdesc:a6b28bfcb67a4123a5b4844e5417a2819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the specified ray, find the closest node that is intersected by that ray and return it. Also return the intersection point on the node.  <a href="#a6b28bfcb67a4123a5b4844e5417a2819"></a><br/></td></tr>
<tr class="separator:a6b28bfcb67a4123a5b4844e5417a2819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bfb7695401ec01e55ec69f44223c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a65bfb7695401ec01e55ec69f44223c3c">pickClosestNode</a> (const <a class="el" href="structcg_size.html">cgSize</a> &amp;viewportSize, const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;rayOrigin, const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;rayDirection, <a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> flags, <a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a> wireTolerance, <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;intersectionOut)</td></tr>
<tr class="memdesc:a65bfb7695401ec01e55ec69f44223c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the specified ray, find the closest node that is intersected by that ray and return it. Also return the intersection point on the node.  <a href="#a65bfb7695401ec01e55ec69f44223c3c"></a><br/></td></tr>
<tr class="separator:a65bfb7695401ec01e55ec69f44223c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312182cd0c701e77feb7619b5fb78c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a312182cd0c701e77feb7619b5fb78c0f">groupSelected</a> (bool asActor)</td></tr>
<tr class="memdesc:a312182cd0c701e77feb7619b5fb78c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group together any currently selected nodes into either a standard collection group, or optionally as an actor.  <a href="#a312182cd0c701e77feb7619b5fb78c0f"></a><br/></td></tr>
<tr class="separator:a312182cd0c701e77feb7619b5fb78c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f721784e6b3154d98d634de47e39331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_group_node.html">cgGroupNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a5f721784e6b3154d98d634de47e39331">groupObjectNodes</a> (cgObjectNodeMap &amp;nodes, bool asActor)</td></tr>
<tr class="memdesc:a5f721784e6b3154d98d634de47e39331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group together the specified nodes into either a standard collection group, or optionally as an actor.  <a href="#a5f721784e6b3154d98d634de47e39331"></a><br/></td></tr>
<tr class="separator:a5f721784e6b3154d98d634de47e39331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c83fc57c62ead2f0651e1cd2eca4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a31c83fc57c62ead2f0651e1cd2eca4d9">ungroupSelected</a> ()</td></tr>
<tr class="memdesc:a31c83fc57c62ead2f0651e1cd2eca4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ungroup any currently selected groups.  <a href="#a31c83fc57c62ead2f0651e1cd2eca4d9"></a><br/></td></tr>
<tr class="separator:a31c83fc57c62ead2f0651e1cd2eca4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa89de64c240ccf99b61b642ae037c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aaa89de64c240ccf99b61b642ae037c74">openSelectedGroups</a> ()</td></tr>
<tr class="memdesc:aaa89de64c240ccf99b61b642ae037c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open any currently selected groups such that their child nodes become available for selection / editing as if they were detached.  <a href="#aaa89de64c240ccf99b61b642ae037c74"></a><br/></td></tr>
<tr class="separator:aaa89de64c240ccf99b61b642ae037c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115bff4ac64bffa5714a5231c587197c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a115bff4ac64bffa5714a5231c587197c">closeSelectedGroups</a> ()</td></tr>
<tr class="memdesc:a115bff4ac64bffa5714a5231c587197c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close any currently selected groups such that their child nodes are no longer available for selection / editing.  <a href="#a115bff4ac64bffa5714a5231c587197c"></a><br/></td></tr>
<tr class="separator:a115bff4ac64bffa5714a5231c587197c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032b99c5b98a367dff848a5020d869e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a032b99c5b98a367dff848a5020d869e1">canGroupSelected</a> () const </td></tr>
<tr class="memdesc:a032b99c5b98a367dff848a5020d869e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the currently selected nodes can be grouped.  <a href="#a032b99c5b98a367dff848a5020d869e1"></a><br/></td></tr>
<tr class="separator:a032b99c5b98a367dff848a5020d869e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe76c59ba900c9c80029a1b27dc9707"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aafe76c59ba900c9c80029a1b27dc9707">canGroupObjectNodes</a> (const cgObjectNodeMap &amp;nodes) const </td></tr>
<tr class="memdesc:aafe76c59ba900c9c80029a1b27dc9707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified nodes can be grouped.  <a href="#aafe76c59ba900c9c80029a1b27dc9707"></a><br/></td></tr>
<tr class="separator:aafe76c59ba900c9c80029a1b27dc9707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28295f8aa8757173928c5e43d21a27ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a28295f8aa8757173928c5e43d21a27ff">canUngroupSelected</a> () const </td></tr>
<tr class="memdesc:a28295f8aa8757173928c5e43d21a27ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the currently selected nodes can be ungrouped.  <a href="#a28295f8aa8757173928c5e43d21a27ff"></a><br/></td></tr>
<tr class="separator:a28295f8aa8757173928c5e43d21a27ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceba375a1e9dd6501cfd494fb1da142"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a4ceba375a1e9dd6501cfd494fb1da142">canOpenSelectedGroups</a> () const </td></tr>
<tr class="memdesc:a4ceba375a1e9dd6501cfd494fb1da142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if any groups are currently selected and if they can be opened.  <a href="#a4ceba375a1e9dd6501cfd494fb1da142"></a><br/></td></tr>
<tr class="separator:a4ceba375a1e9dd6501cfd494fb1da142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf30ca4d7b91c2e7b82bd080178fe8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aebf30ca4d7b91c2e7b82bd080178fe8e">canCloseSelectedGroups</a> () const </td></tr>
<tr class="memdesc:aebf30ca4d7b91c2e7b82bd080178fe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if any groups are currently selected and if they can be closed.  <a href="#aebf30ca4d7b91c2e7b82bd080178fe8e"></a><br/></td></tr>
<tr class="separator:aebf30ca4d7b91c2e7b82bd080178fe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ff4562609f34dcb30fa0485e87a1fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a74ff4562609f34dcb30fa0485e87a1fc">detachSelected</a> ()</td></tr>
<tr class="memdesc:a74ff4562609f34dcb30fa0485e87a1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any currently selected nodes from their parents.  <a href="#a74ff4562609f34dcb30fa0485e87a1fc"></a><br/></td></tr>
<tr class="separator:a74ff4562609f34dcb30fa0485e87a1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27442b2f99320fe201c431d095b734f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a27442b2f99320fe201c431d095b734f8">createSelectionSet</a> (const <a class="el" href="classcg_string.html">cgString</a> &amp;name, bool internalSet, bool overwrite)</td></tr>
<tr class="memdesc:a27442b2f99320fe201c431d095b734f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a selection set from the current list of selected nodes. This entire set of nodes can then be re-selected later in a single step.  <a href="#a27442b2f99320fe201c431d095b734f8"></a><br/></td></tr>
<tr class="separator:a27442b2f99320fe201c431d095b734f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b7fa8ddf02fb1075b87b8e67afcc03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a54b7fa8ddf02fb1075b87b8e67afcc03">removeSelectionSet</a> (const <a class="el" href="classcg_string.html">cgString</a> &amp;name)</td></tr>
<tr class="memdesc:a54b7fa8ddf02fb1075b87b8e67afcc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously created selection set.  <a href="#a54b7fa8ddf02fb1075b87b8e67afcc03"></a><br/></td></tr>
<tr class="separator:a54b7fa8ddf02fb1075b87b8e67afcc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c816b715d1bf2f5984c34a31ca17d96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a5c816b715d1bf2f5984c34a31ca17d96">applySelectionSet</a> (const <a class="el" href="classcg_string.html">cgString</a> &amp;name, bool clearCurrent)</td></tr>
<tr class="memdesc:a5c816b715d1bf2f5984c34a31ca17d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the specified selection set, selecting all referenced nodes.  <a href="#a5c816b715d1bf2f5984c34a31ca17d96"></a><br/></td></tr>
<tr class="separator:a5c816b715d1bf2f5984c34a31ca17d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0ea056ef518f08731debc400b8fc18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a2c0ea056ef518f08731debc400b8fc18">cloneSelected</a> (<a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a> method, cgObjectNodeMap &amp;nodes, bool internalNode)</td></tr>
<tr class="memdesc:a2c0ea056ef518f08731debc400b8fc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the current selection and create new copies, references or instances.  <a href="#a2c0ea056ef518f08731debc400b8fc18"></a><br/></td></tr>
<tr class="separator:a2c0ea056ef518f08731debc400b8fc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd2ab4f3ada30f288740f4a711bfe83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0fd2ab4f3ada30f288740f4a711bfe83">cloneSelected</a> (<a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a> method, cgObjectNodeMap &amp;nodes, bool internalNode, <a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> cloneCount, const <a class="el" href="classcg_transform.html">cgTransform</a> &amp;transformDelta, <a class="el" href="namespacecg_operation_space.html#a2c7bf47ddd2a55700fe387359c07f002">cgOperationSpace::Base</a> transformSpace)</td></tr>
<tr class="memdesc:a0fd2ab4f3ada30f288740f4a711bfe83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the current selection and create new copies, references or instances. Each new clone will be transformed based on the delta matrix specified.  <a href="#a0fd2ab4f3ada30f288740f4a711bfe83"></a><br/></td></tr>
<tr class="separator:a0fd2ab4f3ada30f288740f4a711bfe83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213258294bb4d00814f87de591d749b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a213258294bb4d00814f87de591d749b0">applyMaterialToSelected</a> (<a class="el" href="classcg_material.html">cgMaterial</a> *material)</td></tr>
<tr class="memdesc:a213258294bb4d00814f87de591d749b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the specified material to all selected mesh nodes.  <a href="#a213258294bb4d00814f87de591d749b0"></a><br/></td></tr>
<tr class="separator:a213258294bb4d00814f87de591d749b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ce3478a767dd7378669e0a4da0ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#adf3ce3478a767dd7378669e0a4da0ce4">resetSelectedScale</a> ()</td></tr>
<tr class="memdesc:adf3ce3478a767dd7378669e0a4da0ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the scale transforms of all selected nodes.  <a href="#adf3ce3478a767dd7378669e0a4da0ce4"></a><br/></td></tr>
<tr class="separator:adf3ce3478a767dd7378669e0a4da0ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01e9a9ee1e67d118f8574ca0746bb20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ae01e9a9ee1e67d118f8574ca0746bb20">resetSelectedOrientation</a> ()</td></tr>
<tr class="memdesc:ae01e9a9ee1e67d118f8574ca0746bb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the orientation transforms of all selected nodes.  <a href="#ae01e9a9ee1e67d118f8574ca0746bb20"></a><br/></td></tr>
<tr class="separator:ae01e9a9ee1e67d118f8574ca0746bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f5b138d8e030de31631cc6b04e9011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a66f5b138d8e030de31631cc6b04e9011">resetSelectedPivot</a> ()</td></tr>
<tr class="memdesc:a66f5b138d8e030de31631cc6b04e9011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pivot point of all selected nodes.  <a href="#a66f5b138d8e030de31631cc6b04e9011"></a><br/></td></tr>
<tr class="separator:a66f5b138d8e030de31631cc6b04e9011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b12555860991525aa4054836a2bd211"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a9b12555860991525aa4054836a2bd211">onSceneLoadProgress</a> (<a class="el" href="structcg_scene_load_progress_event_args.html">cgSceneLoadProgressEventArgs</a> *e)</td></tr>
<tr class="memdesc:a9b12555860991525aa4054836a2bd211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a9b12555860991525aa4054836a2bd211"></a><br/></td></tr>
<tr class="separator:a9b12555860991525aa4054836a2bd211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3188f9e3e340c396ce077626691b963f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3188f9e3e340c396ce077626691b963f">onSceneDirtyChange</a> (<a class="el" href="structcg_scene_event_args.html">cgSceneEventArgs</a> *e)</td></tr>
<tr class="memdesc:a3188f9e3e340c396ce077626691b963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a3188f9e3e340c396ce077626691b963f"></a><br/></td></tr>
<tr class="separator:a3188f9e3e340c396ce077626691b963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36567ab4220d274815bd6bb9efb2ed1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#af36567ab4220d274815bd6bb9efb2ed1">onNodeAdded</a> (<a class="el" href="structcg_node_updated_event_args.html">cgNodeUpdatedEventArgs</a> *e)</td></tr>
<tr class="memdesc:af36567ab4220d274815bd6bb9efb2ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#af36567ab4220d274815bd6bb9efb2ed1"></a><br/></td></tr>
<tr class="separator:af36567ab4220d274815bd6bb9efb2ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b445622d3e81fb54ac5f5afc0503e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a52b445622d3e81fb54ac5f5afc0503e5">onNodeNameChange</a> (<a class="el" href="structcg_node_updated_event_args.html">cgNodeUpdatedEventArgs</a> *e)</td></tr>
<tr class="memdesc:a52b445622d3e81fb54ac5f5afc0503e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a52b445622d3e81fb54ac5f5afc0503e5"></a><br/></td></tr>
<tr class="separator:a52b445622d3e81fb54ac5f5afc0503e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a918f39364b1a2cb51266d9536c8c6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a89a918f39364b1a2cb51266d9536c8c6">onNodeParentChange</a> (<a class="el" href="structcg_node_parent_change_event_args.html">cgNodeParentChangeEventArgs</a> *e)</td></tr>
<tr class="memdesc:a89a918f39364b1a2cb51266d9536c8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a89a918f39364b1a2cb51266d9536c8c6"></a><br/></td></tr>
<tr class="separator:a89a918f39364b1a2cb51266d9536c8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e61613c09d3c6e9e892fabc7489de6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a72e61613c09d3c6e9e892fabc7489de6">onNodeDeleted</a> (<a class="el" href="structcg_node_updated_event_args.html">cgNodeUpdatedEventArgs</a> *e)</td></tr>
<tr class="memdesc:a72e61613c09d3c6e9e892fabc7489de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a72e61613c09d3c6e9e892fabc7489de6"></a><br/></td></tr>
<tr class="separator:a72e61613c09d3c6e9e892fabc7489de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218ea8e361f24b87f634740f9111ca84"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a218ea8e361f24b87f634740f9111ca84">onNodesDeleted</a> (<a class="el" href="structcg_nodes_updated_event_args.html">cgNodesUpdatedEventArgs</a> *e)</td></tr>
<tr class="memdesc:a218ea8e361f24b87f634740f9111ca84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overridden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a218ea8e361f24b87f634740f9111ca84"></a><br/></td></tr>
<tr class="separator:a218ea8e361f24b87f634740f9111ca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f58be73de6fd333b4af3c457f6db5c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a9f58be73de6fd333b4af3c457f6db5c1">onSceneElementAdded</a> (<a class="el" href="structcg_scene_element_event_args.html">cgSceneElementEventArgs</a> *e)</td></tr>
<tr class="memdesc:a9f58be73de6fd333b4af3c457f6db5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a9f58be73de6fd333b4af3c457f6db5c1"></a><br/></td></tr>
<tr class="separator:a9f58be73de6fd333b4af3c457f6db5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90603475755912b322ad430182d61400"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a90603475755912b322ad430182d61400">onSceneElementDeleted</a> (<a class="el" href="structcg_scene_element_event_args.html">cgSceneElementEventArgs</a> *e)</td></tr>
<tr class="memdesc:a90603475755912b322ad430182d61400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a90603475755912b322ad430182d61400"></a><br/></td></tr>
<tr class="separator:a90603475755912b322ad430182d61400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8218f757afe601cb9c0c70ef24933df3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a8218f757afe601cb9c0c70ef24933df3">onModifySelection</a> (<a class="el" href="structcg_scene_event_args.html">cgSceneEventArgs</a> *e)</td></tr>
<tr class="memdesc:a8218f757afe601cb9c0c70ef24933df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a8218f757afe601cb9c0c70ef24933df3"></a><br/></td></tr>
<tr class="separator:a8218f757afe601cb9c0c70ef24933df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad625a12f19f0c5f296d47f36d714c835"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ad625a12f19f0c5f296d47f36d714c835">onSelectionUpdated</a> (<a class="el" href="structcg_selection_updated_event_args.html">cgSelectionUpdatedEventArgs</a> *e)</td></tr>
<tr class="memdesc:ad625a12f19f0c5f296d47f36d714c835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#ad625a12f19f0c5f296d47f36d714c835"></a><br/></td></tr>
<tr class="separator:ad625a12f19f0c5f296d47f36d714c835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1ce0bc147edc3203766e1eb92f58b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a2b1ce0bc147edc3203766e1eb92f58b9">onSelectionCleared</a> (<a class="el" href="structcg_scene_event_args.html">cgSceneEventArgs</a> *e)</td></tr>
<tr class="memdesc:a2b1ce0bc147edc3203766e1eb92f58b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a2b1ce0bc147edc3203766e1eb92f58b9"></a><br/></td></tr>
<tr class="separator:a2b1ce0bc147edc3203766e1eb92f58b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40061b7038694c2422ecfdfe7044adf6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a40061b7038694c2422ecfdfe7044adf6">onDeleteSelection</a> (<a class="el" href="structcg_scene_event_args.html">cgSceneEventArgs</a> *e)</td></tr>
<tr class="memdesc:a40061b7038694c2422ecfdfe7044adf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a40061b7038694c2422ecfdfe7044adf6"></a><br/></td></tr>
<tr class="separator:a40061b7038694c2422ecfdfe7044adf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ca8ade5ff06b2ea5dcc0738931b888"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ae5ca8ade5ff06b2ea5dcc0738931b888">onSelectionSetAdded</a> (<a class="el" href="structcg_selection_set_event_args.html">cgSelectionSetEventArgs</a> *e)</td></tr>
<tr class="memdesc:ae5ca8ade5ff06b2ea5dcc0738931b888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#ae5ca8ade5ff06b2ea5dcc0738931b888"></a><br/></td></tr>
<tr class="separator:ae5ca8ade5ff06b2ea5dcc0738931b888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6e68eb0d70e989f228ae11b1867cc6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#acd6e68eb0d70e989f228ae11b1867cc6">onSelectionSetRemoved</a> (<a class="el" href="structcg_selection_set_event_args.html">cgSelectionSetEventArgs</a> *e)</td></tr>
<tr class="memdesc:acd6e68eb0d70e989f228ae11b1867cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#acd6e68eb0d70e989f228ae11b1867cc6"></a><br/></td></tr>
<tr class="separator:acd6e68eb0d70e989f228ae11b1867cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22169d211e9567616a6afb0492a0f8f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a22169d211e9567616a6afb0492a0f8f6">onMaterialAdded</a> (<a class="el" href="structcg_scene_material_event_args.html">cgSceneMaterialEventArgs</a> *e)</td></tr>
<tr class="memdesc:a22169d211e9567616a6afb0492a0f8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a22169d211e9567616a6afb0492a0f8f6"></a><br/></td></tr>
<tr class="separator:a22169d211e9567616a6afb0492a0f8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2993f8a7700861e13be7d0184ec67f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a7f2993f8a7700861e13be7d0184ec67f">onMaterialRemoved</a> (<a class="el" href="structcg_scene_material_event_args.html">cgSceneMaterialEventArgs</a> *e)</td></tr>
<tr class="memdesc:a7f2993f8a7700861e13be7d0184ec67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified.  <a href="#a7f2993f8a7700861e13be7d0184ec67f"></a><br/></td></tr>
<tr class="separator:a7f2993f8a7700861e13be7d0184ec67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7bbe87fdac2901fee2417585fa757a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#abf7bbe87fdac2901fee2417585fa757a">onPhysicsStep</a> (<a class="el" href="classcg_physics_world.html">cgPhysicsWorld</a> *sender, <a class="el" href="structcg_physics_world_step_event_args.html">cgPhysicsWorldStepEventArgs</a> *e)</td></tr>
<tr class="memdesc:abf7bbe87fdac2901fee2417585fa757a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event triggered each time the physics world steps for a single iteration.  <a href="#abf7bbe87fdac2901fee2417585fa757a"></a><br/></td></tr>
<tr class="separator:abf7bbe87fdac2901fee2417585fa757a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5418f9715ac264bedaf2719f0e6826f9"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a5418f9715ac264bedaf2719f0e6826f9">getReferenceType</a> () const </td></tr>
<tr class="separator:a5418f9715ac264bedaf2719f0e6826f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499a1d7174f41899f2b24fb62b4f471a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a499a1d7174f41899f2b24fb62b4f471a">queryReferenceType</a> (const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;type) const </td></tr>
<tr class="memdesc:a499a1d7174f41899f2b24fb62b4f471a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the application to determine if the inheritance hierarchy supports a particular interface.  <a href="#a499a1d7174f41899f2b24fb62b4f471a"></a><br/></td></tr>
<tr class="separator:a499a1d7174f41899f2b24fb62b4f471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac295103b2d5d7e49bb39352e9416435d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ac295103b2d5d7e49bb39352e9416435d">processMessage</a> (<a class="el" href="classcg_message.html">cgMessage</a> *message)</td></tr>
<tr class="memdesc:ac295103b2d5d7e49bb39352e9416435d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process any messages sent to us from other objects, or other parts of the system via the reference messaging system (<a class="el" href="classcg_reference.html" title="Base class which provides standardized reference counting behaviors in addition to recording informat...">cgReference</a>).  <a href="#ac295103b2d5d7e49bb39352e9416435d"></a><br/></td></tr>
<tr class="separator:ac295103b2d5d7e49bb39352e9416435d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5623458a9abe0ddbbf65adf892cd8e87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a5623458a9abe0ddbbf65adf892cd8e87">dispose</a> (bool disposeBase)</td></tr>
<tr class="memdesc:a5623458a9abe0ddbbf65adf892cd8e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any memory, references or resources allocated by this object.  <a href="#a5623458a9abe0ddbbf65adf892cd8e87"></a><br/></td></tr>
<tr class="separator:a5623458a9abe0ddbbf65adf892cd8e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcg_reference"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcg_reference')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcg_reference.html">cgReference</a></td></tr>
<tr class="memitem:aa8f452d66f4666a9b79f1c00d65c6fc6 inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#aa8f452d66f4666a9b79f1c00d65c6fc6">cgReference</a> (<a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> referenceId)</td></tr>
<tr class="separator:aa8f452d66f4666a9b79f1c00d65c6fc6 inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ca8e160d1149ddf7b37bd54dca5039 inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#aa3ca8e160d1149ddf7b37bd54dca5039">~cgReference</a> ()</td></tr>
<tr class="memdesc:aa3ca8e160d1149ddf7b37bd54dca5039 inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up any resources being used.  <a href="#aa3ca8e160d1149ddf7b37bd54dca5039"></a><br/></td></tr>
<tr class="separator:aa3ca8e160d1149ddf7b37bd54dca5039 inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee67b39d9e7eeaaae61a192cd60666a inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a4ee67b39d9e7eeaaae61a192cd60666a">addReference</a> (<a class="el" href="classcg_reference.html">cgReference</a> *holder)</td></tr>
<tr class="memdesc:a4ee67b39d9e7eeaaae61a192cd60666a inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a reference to this object. Required for automatic lifetime management. Specify true to the 'reconnecting' parameter if the reference holder is simply re-establishing an earlier reference. In this case, any soft reference count will not be incremented (default is false).  <a href="#a4ee67b39d9e7eeaaae61a192cd60666a"></a><br/></td></tr>
<tr class="separator:a4ee67b39d9e7eeaaae61a192cd60666a inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8d5cc42aa5f11c5e3b4f516028dbbc inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a2d8d5cc42aa5f11c5e3b4f516028dbbc">removeReference</a> (<a class="el" href="classcg_reference.html">cgReference</a> *holder)</td></tr>
<tr class="memdesc:a2d8d5cc42aa5f11c5e3b4f516028dbbc inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a reference to this object. Required for automatic lifetime management. Specify true to the 'disconnecting' parameter if the reference holder wants its reference removed from the list without the overall reference count being decremented (Default is false).  <a href="#a2d8d5cc42aa5f11c5e3b4f516028dbbc"></a><br/></td></tr>
<tr class="separator:a2d8d5cc42aa5f11c5e3b4f516028dbbc inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39b5070dddf689a5d6c7197ba7e440d inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#ab39b5070dddf689a5d6c7197ba7e440d">addReference</a> (<a class="el" href="classcg_reference.html">cgReference</a> *holder, bool reconnecting)</td></tr>
<tr class="separator:ab39b5070dddf689a5d6c7197ba7e440d inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa6e3198b75c2e94accf7bad303843a inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#acaa6e3198b75c2e94accf7bad303843a">removeReference</a> (<a class="el" href="classcg_reference.html">cgReference</a> *holder, bool disconnecting)</td></tr>
<tr class="separator:acaa6e3198b75c2e94accf7bad303843a inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4089bc9fc24b2e0bcc96376abd6c041c inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a4089bc9fc24b2e0bcc96376abd6c041c">deleteReference</a> ()</td></tr>
<tr class="memdesc:a4089bc9fc24b2e0bcc96376abd6c041c inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the deletion of this reference target.  <a href="#a4089bc9fc24b2e0bcc96376abd6c041c"></a><br/></td></tr>
<tr class="separator:a4089bc9fc24b2e0bcc96376abd6c041c inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0ce63a0c603addc66b2736cbdc5443 inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a4d0ce63a0c603addc66b2736cbdc5443">onReferenceAdded</a> (<a class="el" href="classcg_reference.html">cgReference</a> *holder, <a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a> holderReferences, bool reconnecting)</td></tr>
<tr class="memdesc:a4d0ce63a0c603addc66b2736cbdc5443 inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered whenever a new reference to this object is added by a holder. Derived objects may override this virtual if they need to be informed for any reason.  <a href="#a4d0ce63a0c603addc66b2736cbdc5443"></a><br/></td></tr>
<tr class="separator:a4d0ce63a0c603addc66b2736cbdc5443 inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6b039d22947453f9fecd578aa36986 inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a6c6b039d22947453f9fecd578aa36986">onReferenceRemoved</a> (<a class="el" href="classcg_reference.html">cgReference</a> *holder, <a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a> holderReferences, bool disconnecting)</td></tr>
<tr class="memdesc:a6c6b039d22947453f9fecd578aa36986 inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered whenever an existing reference to this object is removed by a holder. Derived objects may override this virtual if they need to be informed for any reason.  <a href="#a6c6b039d22947453f9fecd578aa36986"></a><br/></td></tr>
<tr class="separator:a6c6b039d22947453f9fecd578aa36986 inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc11be6582c83be070816daf60d96781 inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#abc11be6582c83be070816daf60d96781">isInternalReference</a> () const </td></tr>
<tr class="memdesc:abc11be6582c83be070816daf60d96781 inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this reference is either an internal or serialized reference.  <a href="#abc11be6582c83be070816daf60d96781"></a><br/></td></tr>
<tr class="separator:abc11be6582c83be070816daf60d96781 inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34951860e42866aff9b890d704bccbc4 inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a34951860e42866aff9b890d704bccbc4">isDisposed</a> () const </td></tr>
<tr class="memdesc:a34951860e42866aff9b890d704bccbc4 inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this object has been disposed.  <a href="#a34951860e42866aff9b890d704bccbc4"></a><br/></td></tr>
<tr class="separator:a34951860e42866aff9b890d704bccbc4 inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf67c7fc72ba0d465096b4584e1caba inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#aecf67c7fc72ba0d465096b4584e1caba">isDisposing</a> () const </td></tr>
<tr class="memdesc:aecf67c7fc72ba0d465096b4584e1caba inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this object is in the process of being disposed.  <a href="#aecf67c7fc72ba0d465096b4584e1caba"></a><br/></td></tr>
<tr class="separator:aecf67c7fc72ba0d465096b4584e1caba inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa045c0d8acb58f600a5858b7e7e6ea0d inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#aa045c0d8acb58f600a5858b7e7e6ea0d">getReferenceId</a> () const </td></tr>
<tr class="memdesc:aa045c0d8acb58f600a5858b7e7e6ea0d inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve this object's globally unique identifier.  <a href="#aa045c0d8acb58f600a5858b7e7e6ea0d"></a><br/></td></tr>
<tr class="separator:aa045c0d8acb58f600a5858b7e7e6ea0d inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcec0309494f0ef9a916666336680ee3 inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#afcec0309494f0ef9a916666336680ee3">getReferenceCount</a> (bool live) const </td></tr>
<tr class="memdesc:afcec0309494f0ef9a916666336680ee3 inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve this object's current live or soft reference counts.  <a href="#afcec0309494f0ef9a916666336680ee3"></a><br/></td></tr>
<tr class="separator:afcec0309494f0ef9a916666336680ee3 inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6515831ac3acc3bf0d9b866b425b941 inherit pub_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">const ReferenceMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#ab6515831ac3acc3bf0d9b866b425b941">getReferenceHolders</a> () const </td></tr>
<tr class="memdesc:ab6515831ac3acc3bf0d9b866b425b941 inherit pub_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the list of reference objects which have reported their holding of a pointer to <em>this</em> reference.  <a href="#ab6515831ac3acc3bf0d9b866b425b941"></a><br/></td></tr>
<tr class="separator:ab6515831ac3acc3bf0d9b866b425b941 inherit pub_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcg_event_dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcg_event_dispatcher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcg_event_dispatcher.html">cgEventDispatcher</a></td></tr>
<tr class="memitem:a4e8d6f526bb6f37b59bf905b5c3ab020 inherit pub_methods_classcg_event_dispatcher"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_event_dispatcher.html#a4e8d6f526bb6f37b59bf905b5c3ab020">~cgEventDispatcher</a> ()</td></tr>
<tr class="memdesc:a4e8d6f526bb6f37b59bf905b5c3ab020 inherit pub_methods_classcg_event_dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for this class.  <a href="#a4e8d6f526bb6f37b59bf905b5c3ab020"></a><br/></td></tr>
<tr class="separator:a4e8d6f526bb6f37b59bf905b5c3ab020 inherit pub_methods_classcg_event_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727bae382e3f775b90d422a9ab02d7ed inherit pub_methods_classcg_event_dispatcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_event_dispatcher.html#a727bae382e3f775b90d422a9ab02d7ed">registerEventListener</a> (<a class="el" href="classcg_event_listener.html">cgEventListener</a> *listener)</td></tr>
<tr class="memdesc:a727bae382e3f775b90d422a9ab02d7ed inherit pub_methods_classcg_event_dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method in order to add any object derived from '<a class="el" href="classcg_event_listener.html" title="Abstract interface class from which other listener classes can derive in order to recieve messages wh...">cgEventListener</a>' to which you would like the associated event methods called.  <a href="#a727bae382e3f775b90d422a9ab02d7ed"></a><br/></td></tr>
<tr class="separator:a727bae382e3f775b90d422a9ab02d7ed inherit pub_methods_classcg_event_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38871eb70b6dce541d89e3f436d888d inherit pub_methods_classcg_event_dispatcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_event_dispatcher.html#ac38871eb70b6dce541d89e3f436d888d">unregisterEventListener</a> (<a class="el" href="classcg_event_listener.html">cgEventListener</a> *listener)</td></tr>
<tr class="memdesc:ac38871eb70b6dce541d89e3f436d888d inherit pub_methods_classcg_event_dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified object from the event listener list.  <a href="#ac38871eb70b6dce541d89e3f436d888d"></a><br/></td></tr>
<tr class="separator:ac38871eb70b6dce541d89e3f436d888d inherit pub_methods_classcg_event_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcg_script_interop_1_1_disposable_script_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcg_script_interop_1_1_disposable_script_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcg_script_interop_1_1_disposable_script_object.html">cgScriptInterop::DisposableScriptObject</a></td></tr>
<tr class="memitem:a815b9a991113bb99acea9e15af2920a2 inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_script_interop_1_1_disposable_script_object.html#a815b9a991113bb99acea9e15af2920a2">DisposableScriptObject</a> ()</td></tr>
<tr class="separator:a815b9a991113bb99acea9e15af2920a2 inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47d06d33261be75410289bfbca5a76f inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_script_interop_1_1_disposable_script_object.html#ae47d06d33261be75410289bfbca5a76f">~DisposableScriptObject</a> ()</td></tr>
<tr class="separator:ae47d06d33261be75410289bfbca5a76f inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb8bf99532976e578bb5c631b6b554c inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_script_interop_1_1_disposable_script_object.html#acbb8bf99532976e578bb5c631b6b554c">scriptAddRef</a> ()</td></tr>
<tr class="separator:acbb8bf99532976e578bb5c631b6b554c inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dd0fcb0e94571f7af8e2d2afe58120 inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_script_interop_1_1_disposable_script_object.html#ae4dd0fcb0e94571f7af8e2d2afe58120">scriptReleaseRef</a> ()</td></tr>
<tr class="separator:ae4dd0fcb0e94571f7af8e2d2afe58120 inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac736e569233a8c1909bd5f3bdfbf6c inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_script_interop_1_1_disposable_script_object.html#a6ac736e569233a8c1909bd5f3bdfbf6c">scriptDecrementRef</a> ()</td></tr>
<tr class="separator:a6ac736e569233a8c1909bd5f3bdfbf6c inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cc028af4f3b6480abfb1830dddc36d inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_script_interop_1_1_disposable_script_object.html#a36cc028af4f3b6480abfb1830dddc36d">scriptSafeDispose</a> ()</td></tr>
<tr class="separator:a36cc028af4f3b6480abfb1830dddc36d inherit pub_methods_classcg_script_interop_1_1_disposable_script_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcg_physics_world_event_listener"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcg_physics_world_event_listener')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcg_physics_world_event_listener.html">cgPhysicsWorldEventListener</a></td></tr>
<tr class="memitem:ade17a6347361692f9a17de5a1cb03923 inherit pub_methods_classcg_physics_world_event_listener"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_physics_world_event_listener.html#ade17a6347361692f9a17de5a1cb03923">onPrePhysicsStep</a> (<a class="el" href="classcg_physics_world.html">cgPhysicsWorld</a> *sender, <a class="el" href="structcg_physics_world_step_event_args.html">cgPhysicsWorldStepEventArgs</a> *e)</td></tr>
<tr class="separator:ade17a6347361692f9a17de5a1cb03923 inherit pub_methods_classcg_physics_world_event_listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dff855a6ee71cab31617c5d7752242 inherit pub_methods_classcg_physics_world_event_listener"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_physics_world_event_listener.html#a39dff855a6ee71cab31617c5d7752242">onPostPhysicsStep</a> (<a class="el" href="classcg_physics_world.html">cgPhysicsWorld</a> *sender, <a class="el" href="structcg_physics_world_step_event_args.html">cgPhysicsWorldStepEventArgs</a> *e)</td></tr>
<tr class="separator:a39dff855a6ee71cab31617c5d7752242 inherit pub_methods_classcg_physics_world_event_listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcg_event_listener"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcg_event_listener')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcg_event_listener.html">cgEventListener</a></td></tr>
<tr class="memitem:af4bd6ad295f5aab30774738dae42bb20 inherit pub_methods_classcg_event_listener"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_event_listener.html#af4bd6ad295f5aab30774738dae42bb20">~cgEventListener</a> ()</td></tr>
<tr class="separator:af4bd6ad295f5aab30774738dae42bb20 inherit pub_methods_classcg_event_listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a497b6dbfa4d0d54aeaa900ddaa6590dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a497b6dbfa4d0d54aeaa900ddaa6590dc">prepareQueries</a> ()</td></tr>
<tr class="memdesc:a497b6dbfa4d0d54aeaa900ddaa6590dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare any cached world queries as necessary.  <a href="#a497b6dbfa4d0d54aeaa900ddaa6590dc"></a><br/></td></tr>
<tr class="separator:a497b6dbfa4d0d54aeaa900ddaa6590dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacf3780d4622a7a9f6ed5a6abc29d52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#acacf3780d4622a7a9f6ed5a6abc29d52">reloadRenderControl</a> (bool reloadScript)</td></tr>
<tr class="memdesc:acacf3780d4622a7a9f6ed5a6abc29d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload and re-initialize the render control script and the instantitated script object.  <a href="#acacf3780d4622a7a9f6ed5a6abc29d52"></a><br/></td></tr>
<tr class="separator:acacf3780d4622a7a9f6ed5a6abc29d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86806123bf91a8b4c47c01963182d6df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a86806123bf91a8b4c47c01963182d6df">loadObjectNode</a> (<a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> rootReferenceId, <a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> referenceId, <a class="el" href="classcg_world_query.html">cgWorldQuery</a> *nodeData, <a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a> cloneMethod, <a class="el" href="classcg_scene_cell.html">cgSceneCell</a> *parentCell, <a class="el" href="classcg_object_node.html">cgObjectNode</a> *parentNode, cgObjectNodeMap &amp;loadedNodes, bool loadChildren)</td></tr>
<tr class="memdesc:a86806123bf91a8b4c47c01963182d6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recreate a previously existing node, loading it from the database based on the specified data query. Can also recurse through any available child hierarchy on request.  <a href="#a86806123bf91a8b4c47c01963182d6df"></a><br/></td></tr>
<tr class="separator:a86806123bf91a8b4c47c01963182d6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819fed469f5500f3621a3329e4ebe34d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a819fed469f5500f3621a3329e4ebe34d">loadSceneElements</a> ()</td></tr>
<tr class="memdesc:a819fed469f5500f3621a3329e4ebe34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the scene element data from the world database.  <a href="#a819fed469f5500f3621a3329e4ebe34d"></a><br/></td></tr>
<tr class="separator:a819fed469f5500f3621a3329e4ebe34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b2f556e101ef5b776a086d557f8c79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a35b2f556e101ef5b776a086d557f8c79">loadAllCells</a> ()</td></tr>
<tr class="memdesc:a35b2f556e101ef5b776a086d557f8c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the scene data from the world database.  <a href="#a35b2f556e101ef5b776a086d557f8c79"></a><br/></td></tr>
<tr class="separator:a35b2f556e101ef5b776a086d557f8c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcg_reference"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcg_reference')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcg_reference.html">cgReference</a></td></tr>
<tr class="memitem:a6cfceab8378d8ec28490f639d785193a inherit pro_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a6cfceab8378d8ec28490f639d785193a">addRefHold</a> (<a class="el" href="classcg_reference.html">cgReference</a> *reference, bool reconnecting)</td></tr>
<tr class="memdesc:a6cfceab8378d8ec28490f639d785193a inherit pro_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add internal references of the specified object held by this reference holder. This is an internal method that is called only by the target of the reference in order to establish a bi-directional relationship.  <a href="#a6cfceab8378d8ec28490f639d785193a"></a><br/></td></tr>
<tr class="separator:a6cfceab8378d8ec28490f639d785193a inherit pro_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fee3b24b54842b4d378a14cd8a5e1b inherit pro_methods_classcg_reference"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a91fee3b24b54842b4d378a14cd8a5e1b">removeRefHold</a> (<a class="el" href="classcg_reference.html">cgReference</a> *reference, bool disconnecting)</td></tr>
<tr class="memdesc:a91fee3b24b54842b4d378a14cd8a5e1b inherit pro_methods_classcg_reference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove internal references of the specified object held by this reference holder. This is an internal method that is called only by the target of the reference in order to finalize a bi-directional relationship.  <a href="#a91fee3b24b54842b4d378a14cd8a5e1b"></a><br/></td></tr>
<tr class="separator:a91fee3b24b54842b4d378a14cd8a5e1b inherit pro_methods_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac601b64a8a5ec87c9c5c7a2b03c6237a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ac601b64a8a5ec87c9c5c7a2b03c6237a">rayCastPreFilter</a> (<a class="el" href="classcg_physics_body.html">cgPhysicsBody</a> *body, <a class="el" href="classcg_physics_shape.html">cgPhysicsShape</a> *shape, void *userData)</td></tr>
<tr class="memdesc:ac601b64a8a5ec87c9c5c7a2b03c6237a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that will be called by the physics system each time a new collidable body is discovered during broad phase calculations. We can use this to strip away bodies that are of no interest to us early.  <a href="#ac601b64a8a5ec87c9c5c7a2b03c6237a"></a><br/></td></tr>
<tr class="separator:ac601b64a8a5ec87c9c5c7a2b03c6237a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9a3d73c1a413b5227f19e6b9828036"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3f9a3d73c1a413b5227f19e6b9828036">rayCastClosestFilter</a> (<a class="el" href="classcg_physics_body.html">cgPhysicsBody</a> *body, const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;hitNormal, <a class="el" href="cg_base_types_8h.html#a56025923e37960cbd26905608b2f0d06">cgInt</a> collisionId, void *userData, <a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a> intersectParam)</td></tr>
<tr class="memdesc:a3f9a3d73c1a413b5227f19e6b9828036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that will be called by the physics system each time a new collidable body is actually hit during narrow phase calculations.  <a href="#a3f9a3d73c1a413b5227f19e6b9828036"></a><br/></td></tr>
<tr class="separator:a3f9a3d73c1a413b5227f19e6b9828036"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a53f1439e8d86481e6b5e03ba56d5a0df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_world.html">cgWorld</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a53f1439e8d86481e6b5e03ba56d5a0df">mWorld</a></td></tr>
<tr class="separator:a53f1439e8d86481e6b5e03ba56d5a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c4cd5a7ab7df9eb87a97f9d59f3997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_scene_descriptor.html">cgSceneDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a24c4cd5a7ab7df9eb87a97f9d59f3997">mSceneDescriptor</a></td></tr>
<tr class="separator:a24c4cd5a7ab7df9eb87a97f9d59f3997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aac8376260cc801c21a9e41d73192f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_resource_handles_8h.html#a118acf0914cb9c76815e189ac6f8a0c0">cgScriptHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0aac8376260cc801c21a9e41d73192f3">mRenderScript</a></td></tr>
<tr class="separator:a0aac8376260cc801c21a9e41d73192f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa680b7ec9f341e5df707a6dacca2b721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_script_object.html">cgScriptObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aa680b7ec9f341e5df707a6dacca2b721">mScriptObject</a></td></tr>
<tr class="separator:aa680b7ec9f341e5df707a6dacca2b721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b14623acbe6998dfee2789c06d16a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#af6b14623acbe6998dfee2789c06d16a1">mIsLoading</a></td></tr>
<tr class="separator:af6b14623acbe6998dfee2789c06d16a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cd9df9242529ed70035471dab2fb0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a84cd9df9242529ed70035471dab2fb0d">mSuppressEvents</a></td></tr>
<tr class="separator:a84cd9df9242529ed70035471dab2fb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca7dbb3830fdadf2f028a5f072627f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_physics_world.html">cgPhysicsWorld</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#abca7dbb3830fdadf2f028a5f072627f5">mPhysicsWorld</a></td></tr>
<tr class="separator:abca7dbb3830fdadf2f028a5f072627f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0148efe752a0922e10ddd3f3d3b55920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_landscape.html">cgLandscape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a0148efe752a0922e10ddd3f3d3b55920">mLandscape</a></td></tr>
<tr class="separator:a0148efe752a0922e10ddd3f3d3b55920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b53034068cf8871976e1fe4952d5af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_lighting_manager.html">cgLightingManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a8b53034068cf8871976e1fe4952d5af9">mLightingManager</a></td></tr>
<tr class="separator:a8b53034068cf8871976e1fe4952d5af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa310ecfa8623fcca25e20b75f110eddc"><td class="memItemLeft" align="right" valign="top">cgSceneElementArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aa310ecfa8623fcca25e20b75f110eddc">mElements</a></td></tr>
<tr class="separator:aa310ecfa8623fcca25e20b75f110eddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe46dc022cb4ca692777fca46f37f2df"><td class="memItemLeft" align="right" valign="top">SceneElementTypeMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#afe46dc022cb4ca692777fca46f37f2df">mElementTypes</a></td></tr>
<tr class="separator:afe46dc022cb4ca692777fca46f37f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945ecf804902e4ec226e638be2249196"><td class="memItemLeft" align="right" valign="top">cgObjectNodeMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a945ecf804902e4ec226e638be2249196">mObjectNodes</a></td></tr>
<tr class="separator:a945ecf804902e4ec226e638be2249196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0de9779dc95e26e9bb45ec73d51ab33"><td class="memItemLeft" align="right" valign="top">ObjectNodeTypeMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#af0de9779dc95e26e9bb45ec73d51ab33">mObjectNodeTypes</a></td></tr>
<tr class="separator:af0de9779dc95e26e9bb45ec73d51ab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8976236553bdf9e5715d2da951b916f"><td class="memItemLeft" align="right" valign="top">cgObjectNodeMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ae8976236553bdf9e5715d2da951b916f">mRootNodes</a></td></tr>
<tr class="separator:ae8976236553bdf9e5715d2da951b916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade248d285eb9af2263a1e72a0eb4e7f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_camera_node.html">cgCameraNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ade248d285eb9af2263a1e72a0eb4e7f8">mActiveCamera</a></td></tr>
<tr class="separator:ade248d285eb9af2263a1e72a0eb4e7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35761b94855d3f380c0dad6ecc0b844f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcg_scene_1_1_update_bucket.html">UpdateBucket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a35761b94855d3f380c0dad6ecc0b844f">mUpdateBuckets</a> [<a class="el" href="namespacecg_update_rate.html#a0da2807d89bc281aaedc56c1edbdbd24a6c956cd08c69a8f3574b5757eb101898">cgUpdateRate::Count</a>]</td></tr>
<tr class="separator:a35761b94855d3f380c0dad6ecc0b844f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7431b61dd65515bdc3ed905b0ee1f45c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_scene_update_f_i_f_o.html">cgSceneUpdateFIFO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a7431b61dd65515bdc3ed905b0ee1f45c">mPendingUpdateFIFO</a></td></tr>
<tr class="separator:a7431b61dd65515bdc3ed905b0ee1f45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1806f2ddf76f4cfc0609207ef618f101"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a1806f2ddf76f4cfc0609207ef618f101">mUpdatingEnabled</a></td></tr>
<tr class="separator:a1806f2ddf76f4cfc0609207ef618f101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7296b19f0fe364380473a9c38bf31f32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a7296b19f0fe364380473a9c38bf31f32">mIsUpdating</a></td></tr>
<tr class="separator:a7296b19f0fe364380473a9c38bf31f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3ba268c26c0e416910aa42d555ed2c"><td class="memItemLeft" align="right" valign="top">ControllerArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#add3ba268c26c0e416910aa42d555ed2c">mSceneControllers</a></td></tr>
<tr class="separator:add3ba268c26c0e416910aa42d555ed2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e525f99cde6525aed7869556e21c97"><td class="memItemLeft" align="right" valign="top">cgScriptArgument::Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a34e525f99cde6525aed7869556e21c97">mOnSceneRenderArgs</a></td></tr>
<tr class="separator:a34e525f99cde6525aed7869556e21c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65f7c511d39986347a49de695a00398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_script_interop_8h.html#a70afeb5f6d7ee30b8817ed7de4d31a85">cgScriptFunctionHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aa65f7c511d39986347a49de695a00398">mOnSceneRenderMethod</a></td></tr>
<tr class="separator:aa65f7c511d39986347a49de695a00398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b740bd5356fb48e14e083d7dfbac03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a12b740bd5356fb48e14e083d7dfbac03">mPassBegun</a></td></tr>
<tr class="separator:a12b740bd5356fb48e14e083d7dfbac03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be9779fddf78b25ebce8d8e2dbd551f"><td class="memItemLeft" align="right" valign="top">cgSceneCellMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3be9779fddf78b25ebce8d8e2dbd551f">mCells</a></td></tr>
<tr class="separator:a3be9779fddf78b25ebce8d8e2dbd551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c3d4312b142d790ed0486a0dd54648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_sphere_tree.html">cgSphereTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a64c3d4312b142d790ed0486a0dd54648">mSceneTree</a></td></tr>
<tr class="separator:a64c3d4312b142d790ed0486a0dd54648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6d0906085dfd4e2870cc0fa2612ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_b_s_p_tree.html">cgBSPTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a4b6d0906085dfd4e2870cc0fa2612ce8">mStaticVisTree</a></td></tr>
<tr class="separator:a4b6d0906085dfd4e2870cc0fa2612ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ced48c728b77ca9545e3f147f2f53b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a7ced48c728b77ca9545e3f147f2f53b9">mDynamicsEnabled</a></td></tr>
<tr class="separator:a7ced48c728b77ca9545e3f147f2f53b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff1522f4f35246fa698f9aafb6e0506"><td class="memItemLeft" align="right" valign="top">VisibilitySetArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a5ff1522f4f35246fa698f9aafb6e0506">mOrphanVisSets</a></td></tr>
<tr class="separator:a5ff1522f4f35246fa698f9aafb6e0506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3024ef72cabb67af419222dd6ed2b67c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3024ef72cabb67af419222dd6ed2b67c">mIsDirty</a></td></tr>
<tr class="separator:a3024ef72cabb67af419222dd6ed2b67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e726f24f3070348b2c2768ac568c65e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a3e726f24f3070348b2c2768ac568c65e">mSceneWritesEnabled</a></td></tr>
<tr class="separator:a3e726f24f3070348b2c2768ac568c65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6bba9d3e8bfb4a4c1908a01dbda4a5"><td class="memItemLeft" align="right" valign="top">NameUsageMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a1e6bba9d3e8bfb4a4c1908a01dbda4a5">mNameUsage</a></td></tr>
<tr class="separator:a1e6bba9d3e8bfb4a4c1908a01dbda4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f3367cdf5f6eff5bfbbb7532689cde"><td class="memItemLeft" align="right" valign="top">SceneMaterialMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ab9f3367cdf5f6eff5bfbbb7532689cde">mActiveMaterials</a></td></tr>
<tr class="separator:ab9f3367cdf5f6eff5bfbbb7532689cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe256c4ac49f8d6ed354fef417eb435"><td class="memItemLeft" align="right" valign="top">cgObjectNodeMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#aefe256c4ac49f8d6ed354fef417eb435">mSelectedNodes</a></td></tr>
<tr class="separator:aefe256c4ac49f8d6ed354fef417eb435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade594b889435994ba5ffee4756dd2a30"><td class="memItemLeft" align="right" valign="top">cgObjectNodeMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ade594b889435994ba5ffee4756dd2a30">mSelectedNodesOrdered</a></td></tr>
<tr class="separator:ade594b889435994ba5ffee4756dd2a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5218d8ada5ef289bc5dfc695032ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ace5218d8ada5ef289bc5dfc695032ad1">mNextSelectionId</a></td></tr>
<tr class="separator:ace5218d8ada5ef289bc5dfc695032ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bf8d3844064856af2c8fac032af1b2"><td class="memItemLeft" align="right" valign="top">SelectionSetMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#ab4bf8d3844064856af2c8fac032af1b2">mSelectionSets</a></td></tr>
<tr class="separator:ab4bf8d3844064856af2c8fac032af1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2510238df3215a112a6f3e895c372546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcg_u_i_d.html">cgUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a2510238df3215a112a6f3e895c372546">mActiveObjectElementType</a></td></tr>
<tr class="separator:a2510238df3215a112a6f3e895c372546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcg_reference"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcg_reference')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcg_reference.html">cgReference</a></td></tr>
<tr class="memitem:a58ab53765ddfa978c2ef51a3a75bab63 inherit pro_attribs_classcg_reference"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a58ab53765ddfa978c2ef51a3a75bab63">mReferenceId</a></td></tr>
<tr class="separator:a58ab53765ddfa978c2ef51a3a75bab63 inherit pro_attribs_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b5793d4e823c110e1975aaa887487b inherit pro_attribs_classcg_reference"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#ad1b5793d4e823c110e1975aaa887487b">mLiveRefCount</a></td></tr>
<tr class="separator:ad1b5793d4e823c110e1975aaa887487b inherit pro_attribs_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c9bf12615727e2aa9af32d705bb94f inherit pro_attribs_classcg_reference"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#ad5c9bf12615727e2aa9af32d705bb94f">mSoftRefCount</a></td></tr>
<tr class="separator:ad5c9bf12615727e2aa9af32d705bb94f inherit pro_attribs_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3681d5fc05cd6e32d724d397b41ef83 inherit pro_attribs_classcg_reference"><td class="memItemLeft" align="right" valign="top">ReferenceMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#ac3681d5fc05cd6e32d724d397b41ef83">mReferencedBy</a></td></tr>
<tr class="separator:ac3681d5fc05cd6e32d724d397b41ef83 inherit pro_attribs_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e58f7028ccafe6dc1d62834f9b55863 inherit pro_attribs_classcg_reference"><td class="memItemLeft" align="right" valign="top">ReferenceMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a9e58f7028ccafe6dc1d62834f9b55863">mReferencesTo</a></td></tr>
<tr class="separator:a9e58f7028ccafe6dc1d62834f9b55863 inherit pro_attribs_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1749eeb16fa3f3ce834125fbd22d2583 inherit pro_attribs_classcg_reference"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a1749eeb16fa3f3ce834125fbd22d2583">mDisposed</a></td></tr>
<tr class="separator:a1749eeb16fa3f3ce834125fbd22d2583 inherit pro_attribs_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0a1354a2f4ced6aa34688f6f4761e9 inherit pro_attribs_classcg_reference"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_reference.html#a0b0a1354a2f4ced6aa34688f6f4761e9">mDisposing</a></td></tr>
<tr class="separator:a0b0a1354a2f4ced6aa34688f6f4761e9 inherit pro_attribs_classcg_reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcg_event_dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcg_event_dispatcher')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcg_event_dispatcher.html">cgEventDispatcher</a></td></tr>
<tr class="memitem:a60b73d596abf511416b0e36e5b107e1b inherit pro_attribs_classcg_event_dispatcher"><td class="memItemLeft" align="right" valign="top">EventListenerList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_event_dispatcher.html#a60b73d596abf511416b0e36e5b107e1b">mEventListeners</a></td></tr>
<tr class="separator:a60b73d596abf511416b0e36e5b107e1b inherit pro_attribs_classcg_event_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcg_script_interop_1_1_disposable_script_object"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcg_script_interop_1_1_disposable_script_object')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcg_script_interop_1_1_disposable_script_object.html">cgScriptInterop::DisposableScriptObject</a></td></tr>
<tr class="memitem:a5da40dc03376bc8d5c50145690eb5f28 inherit pro_attribs_classcg_script_interop_1_1_disposable_script_object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_script_interop_1_1_disposable_script_object.html#a5da40dc03376bc8d5c50145690eb5f28">mScriptRefCount</a></td></tr>
<tr class="separator:a5da40dc03376bc8d5c50145690eb5f28 inherit pro_attribs_classcg_script_interop_1_1_disposable_script_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a6d65ed44b1d79e0d1044c8ba7daf1b20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcg_world_query.html">cgWorldQuery</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a6d65ed44b1d79e0d1044c8ba7daf1b20">mInsertMaterialUsage</a></td></tr>
<tr class="separator:a6d65ed44b1d79e0d1044c8ba7daf1b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec32b7b61c298859a39774166161fef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcg_world_query.html">cgWorldQuery</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a8ec32b7b61c298859a39774166161fef">mDeleteMaterialUsage</a></td></tr>
<tr class="separator:a8ec32b7b61c298859a39774166161fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2ce0e08fdcc1f21a16fde28be23ddf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcg_world_query.html">cgWorldQuery</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a8d2ce0e08fdcc1f21a16fde28be23ddf">mInsertElementUsage</a></td></tr>
<tr class="separator:a8d2ce0e08fdcc1f21a16fde28be23ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c4134f0e122112437432d9ac265867"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcg_world_query.html">cgWorldQuery</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a03c4134f0e122112437432d9ac265867">mDeleteElementUsage</a></td></tr>
<tr class="separator:a03c4134f0e122112437432d9ac265867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ed598c94d292896026db7d68493923"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcg_world_query.html">cgWorldQuery</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#af2ed598c94d292896026db7d68493923">mLoadObjectNodes</a></td></tr>
<tr class="separator:af2ed598c94d292896026db7d68493923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8e7c3f8e374251645e0e4eef28e017"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcg_world_query.html">cgWorldQuery</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcg_scene.html#a2a8e7c3f8e374251645e0e4eef28e017">mLoadChildObjectNodes</a></td></tr>
<tr class="separator:a2a8e7c3f8e374251645e0e4eef28e017"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main class responsible for loading and managing an individual scene. A scene is essentially a collection of objects which might for instance make up the exterior world (containing a full blown landscape etc.) or the interior of a building. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3acdeafba075b1d94714c840f3373518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cgScene::cgScene </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_world.html">cgWorld</a> *&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_scene_descriptor.html">cgSceneDescriptor</a> *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world in which this scene is to exist.</td></tr>
    <tr><td class="paramname">description</td><td>Description of the high-level properties that should be assumed for the created scene.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9889a2e0985e50b30a22f582395f656"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cgScene::~cgScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class destructor. Falls through to the class' <a class="el" href="classcg_scene.html#a5623458a9abe0ddbbf65adf892cd8e87" title="Release any memory, references or resources allocated by this object. ">dispose()</a> method. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3fb868468b53dc98f74f5b72bd73d44d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::addController </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_scene_controller.html">cgSceneController</a> *&#160;</td>
          <td class="paramname"><em>controller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new scene controller that, when enabled, will be triggered in the scene's update call. </p>

</div>
</div>
<a class="anchor" id="a947a1aff7a1a0fb85f64ba3a374e24b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::addRootNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified object node to the scene as a root node. This is simply a list that outlines all of the nodes that exist at a root level in the hierarchy. </p>

</div>
</div>
<a class="anchor" id="aa6638b85b55312f2b0bc2615470a2428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::addSceneMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_material.html">cgMaterial</a> *&#160;</td>
          <td class="paramname"><em>material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified material to the scene for ownership. This means that the material will show up in the material editor for this scene, and also ensures that the material will never be removed from the database unless it is physically removed from the scene. </p>

</div>
</div>
<a class="anchor" id="a213258294bb4d00814f87de591d749b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::applyMaterialToSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_material.html">cgMaterial</a> *&#160;</td>
          <td class="paramname"><em>material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the specified material to all selected mesh nodes. </p>

</div>
</div>
<a class="anchor" id="ab42a3ea17655eace7d74879ef77d13f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::applySceneRescale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescale all elements in the scene by the desired amount at the local / data level. For instance, a light source will scale its range properties and a mesh will rescale all of its vertices. </p>

</div>
</div>
<a class="anchor" id="a5c816b715d1bf2f5984c34a31ca17d96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::applySelectionSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_string.html">cgString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearCurrent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the specified selection set, selecting all referenced nodes. </p>

</div>
</div>
<a class="anchor" id="ace18bece39a1837aee9614c6a8f8c67e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::beginRenderPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_string.html">cgString</a> &amp;&#160;</td>
          <td class="paramname"><em>passName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called in order to set up the rendering subsystem ready for the caller to take a single draw pass over the scene. Once complete, the caller should call '<a class="el" href="classcg_scene.html#a948127b5f50c1eec82400b8fd565cd0c" title="Called once the current rendering pass has been completed. ">endRenderPass()</a>'. </p>

</div>
</div>
<a class="anchor" id="aebf30ca4d7b91c2e7b82bd080178fe8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::canCloseSelectedGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if any groups are currently selected and if they can be closed. </p>

</div>
</div>
<a class="anchor" id="aafe76c59ba900c9c80029a1b27dc9707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::canGroupObjectNodes </td>
          <td>(</td>
          <td class="paramtype">const cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified nodes can be grouped. </p>

</div>
</div>
<a class="anchor" id="a032b99c5b98a367dff848a5020d869e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::canGroupSelected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the currently selected nodes can be grouped. </p>

</div>
</div>
<a class="anchor" id="a4ceba375a1e9dd6501cfd494fb1da142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::canOpenSelectedGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if any groups are currently selected and if they can be opened. </p>

</div>
</div>
<a class="anchor" id="a28295f8aa8757173928c5e43d21a27ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::canUngroupSelected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the currently selected nodes can be ungrouped. </p>

</div>
</div>
<a class="anchor" id="a5577c13664a2ff9adfd9ba4e420df0bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completely destroy and remove all resident scene nodes and elements leaving a completely empty scene. </p>

</div>
</div>
<a class="anchor" id="aefd51919b62fbe4cba72ab95a459153e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::clearSelection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply clear out the selected nodes list. </p>

</div>
</div>
<a class="anchor" id="a2c0ea056ef518f08731debc400b8fc18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::cloneSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internalNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone the current selection and create new copies, references or instances. </p>

</div>
</div>
<a class="anchor" id="a0fd2ab4f3ada30f288740f4a711bfe83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::cloneSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internalNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td>
          <td class="paramname"><em>cloneCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_transform.html">cgTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transformDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecg_operation_space.html#a2c7bf47ddd2a55700fe387359c07f002">cgOperationSpace::Base</a>&#160;</td>
          <td class="paramname"><em>transformSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone the current selection and create new copies, references or instances. Each new clone will be transformed based on the delta matrix specified. </p>

</div>
</div>
<a class="anchor" id="a115bff4ac64bffa5714a5231c587197c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::closeSelectedGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close any currently selected groups such that their child nodes are no longer available for selection / editing. </p>

</div>
</div>
<a class="anchor" id="aaa499db21ab6e4995d2caecbe0639f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::computeVisibility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_frustum.html">cgFrustum</a> &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcg_visibility_set.html">cgVisibilitySet</a> *&#160;</td>
          <td class="paramname"><em>visibilityData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by the application to allow us to retrieve leaf visibility information and rendering subsets. </p>

</div>
</div>
<a class="anchor" id="aef75fb094862a793fafc75e7c91cd9bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_object_node.html">cgObjectNode</a> * cgScene::createObjectNode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internalNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;&#160;</td>
          <td class="paramname"><em>objectTypeIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoAssignName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new node of the specified type and add it to the scene's node database. </p>

</div>
</div>
<a class="anchor" id="acd88ba85b0a18b3148d8cd07c4bc9cd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_object_node.html">cgObjectNode</a> * cgScene::createObjectNode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internalNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;&#160;</td>
          <td class="paramname"><em>objectTypeIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoAssignName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a>&#160;</td>
          <td class="paramname"><em>cloneMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>nodeInit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_transform.html">cgTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>initTransform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new node of the specified type and add it to the scene's node database. The new node should represent a clone of the specified initializing node, cloned using the provided method. </p>

</div>
</div>
<a class="anchor" id="a7ff0cd76db156903a639ac31b7293446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_scene_element.html">cgSceneElement</a> * cgScene::createSceneElement </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internalElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;&#160;</td>
          <td class="paramname"><em>elementTypeIdentifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new scene element of the specified type and add it to the scene's child element database. </p>

</div>
</div>
<a class="anchor" id="a27442b2f99320fe201c431d095b734f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::createSelectionSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_string.html">cgString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internalSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a selection set from the current list of selected nodes. This entire set of nodes can then be re-selected later in a single step. </p>

</div>
</div>
<a class="anchor" id="a99733b4ad551388cf7466ed2a11730f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::deleteObjectNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call in order to delete a single specified node from the scene database. </p>

</div>
</div>
<a class="anchor" id="a85f9a7bfd285e447d0a32e4c4e547537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::deleteObjectNodes </td>
          <td>(</td>
          <td class="paramtype">cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call in order to delete a whole list of specified nodes from the scene database in one go. </p>

</div>
</div>
<a class="anchor" id="aef9172d6387a27760878c7f4d4e126d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::deleteSceneElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_scene_element.html">cgSceneElement</a> *&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the specified material from the scene's material ownership list. If the scene was the last live item reference that material, and if it held the last 'soft' reference it will be deleted from the database. </p>

</div>
</div>
<a class="anchor" id="a4af71dd70f74e777103215663c34a29f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::deleteSelected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete any currently selected nodes. </p>

</div>
</div>
<a class="anchor" id="a74ff4562609f34dcb30fa0485e87a1fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::detachSelected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete any currently selected nodes from their parents. </p>

</div>
</div>
<a class="anchor" id="a5623458a9abe0ddbbf65adf892cd8e87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::dispose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disposeBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any memory, references or resources allocated by this object. </p>
<p>&lt;copydetails cref="cgScriptInterop::DisposableScriptObject::dispose()"&gt; </p>

<p>Reimplemented from <a class="el" href="classcg_reference.html#af081655ab5cc38075fc2fd3d5d7cd879">cgReference</a>.</p>

</div>
</div>
<a class="anchor" id="a3bcc82d6ef3896c2b5c566b7c41eb835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::enableDynamics </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state which determines whether scene dynamics processing (physics updates) are currently enabled. </p>

</div>
</div>
<a class="anchor" id="a071a1ce228c073776117c816926c1d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::enableSceneWrites </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable the ability for nodes to serialize their transformation updates to the scene database. </p>

</div>
</div>
<a class="anchor" id="afc2f7b31f998d700b6aedd1930b1106b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::enableUpdates </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state which determines whether scene objects will automatically receive calls to their 'update' method during scene update processing. </p>

</div>
</div>
<a class="anchor" id="a948127b5f50c1eec82400b8fd565cd0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::endRenderPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called once the current rendering pass has been completed. </p>

</div>
</div>
<a class="anchor" id="a0ee07f72d57cf5c0a5fe8a2025ed65ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_camera_node.html">cgCameraNode</a> * cgScene::getActiveCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the currently active scene camera object. </p>

</div>
</div>
<a class="anchor" id="a0dca6648d56aa02bea4bb991dc06074e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp; cgScene::getActiveObjectElementType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique identifier of the element type / category which the application / sandbox environment considers 'active'. An identifier of <a class="el" href="classcg_u_i_d.html#ae0bb84d8bdcdfad56e2d42ea7693a8c7">cgUID::Empty</a> means that standard top level nodes are considered 'active'. </p>

</div>
</div>
<a class="anchor" id="a9127b59ef958523c24060da0fafcad16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp; cgScene::getCellSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the specified size of each individual cell used for scene management. </p>

</div>
</div>
<a class="anchor" id="a3f4d0a2adc71d8a3674987992471c2fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecg_unit_type.html#a3cddff019459e19bbec2d48d5887ea46">cgUnitType::Base</a> cgScene::getDistanceDisplayUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the unit type that the artist has selected for displaying distance values. </p>

</div>
</div>
<a class="anchor" id="a950db52f5394e9ac553a0c0ca8987ffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_landscape.html">cgLandscape</a> * cgScene::getLandscape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply retrieve any landscape associated with this scene. </p>

</div>
</div>
<a class="anchor" id="a116d1725225823fcd9b662544e62661e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_lighting_manager.html">cgLightingManager</a> * cgScene::getLightingManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the scene's internal lighting manager. </p>

</div>
</div>
<a class="anchor" id="aa0c2561766b6aeb25f9da41c9bf2d9e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cgFilterExpression::IdentifierArray &amp; cgScene::getMaterialPropertyIdentifiers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the pre-constructed list of identifiers (compatible with <a class="el" href="classcg_filter_expression.html" title="A utility class that allows for complex (string based) boolean style expressions to be supplied that ...">cgFilterExpression</a>) for the various user defined material properties types. </p>

</div>
</div>
<a class="anchor" id="a1ab4a89e68d1704f3feef14d1231324b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcg_string.html">cgString</a> &amp; cgScene::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply retrieve the name of this loaded scene. </p>

</div>
</div>
<a class="anchor" id="a9d44967ed064ea7d5679709fc18cdf14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cgScene::NameUsageMap &amp; cgScene::getNameUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the map that contains a list of all the node names currently in use within the scene at this time. </p>

</div>
</div>
<a class="anchor" id="a3180b398f52ae1d6dc7ebbd8fbff2af2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a> cgScene::getNextSelectionId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the next consecutive integer identifier that can be used to determine the order in which nodes were selected. </p>

</div>
</div>
<a class="anchor" id="a729c2c060a461c158889a07e1fd9b0f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_object_node.html">cgObjectNode</a> * cgScene::getObjectNodeById </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td>
          <td class="paramname"><em>referenceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the object node with the specified reference identifier if it exists within the database of currently loaded (or created) scene objects. </p>

</div>
</div>
<a class="anchor" id="abc90e81d9315338852772c007421a65d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cgObjectNodeMap &amp; cgScene::getObjectNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a complete list of all scene object nodes. </p>

</div>
</div>
<a class="anchor" id="a6e7fe1f02051b74108ede9da028f865c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cgObjectNodeMap &amp; cgScene::getObjectNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a complete list of all scene object nodes. </p>

</div>
</div>
<a class="anchor" id="a19d43539a431f05299caa26b5cb3ec94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cgObjectNodeArray &amp; cgScene::getObjectNodesByType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a list of all allocated scene object nodes of the specified type. </p>

</div>
</div>
<a class="anchor" id="a90f9fc119b84f9b1682515eef78bf0dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::getObjectNodesInBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cgObjectNodeArray &amp;&#160;</td>
          <td class="paramname"><em>nodesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the specified container with references to all allocated scene object nodes that fall within the specified bounding sphere. </p>

</div>
</div>
<a class="anchor" id="aa914740b53b80d6aa50ac2ee151c910e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::getObjectNodesInBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_bounding_box.html">cgBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cgObjectNodeArray &amp;&#160;</td>
          <td class="paramname"><em>nodesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the specified container with references to all allocated scene object nodes that fall within the specified bounding box. </p>

</div>
</div>
<a class="anchor" id="afcb9764f7e183c2699d047c41e9f4cb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::getObjectNodesPivot </td>
          <td>(</td>
          <td class="paramtype">const cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pivotOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a world space point about which specified nodes should pivot during rotation for instance. If one node is select, this will be its origin, otherwise it will be the average of all selected node origins. </p>

</div>
</div>
<a class="anchor" id="a36302e3a7d0da535f0456581d6e3e7d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_world.html">cgWorld</a> * cgScene::getParentWorld </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the world to which this scene belongs. </p>

</div>
</div>
<a class="anchor" id="ab9502b6cfc1b46efa6327bbc515fe9be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_physics_world.html">cgPhysicsWorld</a> * cgScene::getPhysicsWorld </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the scene's internal physics simulation world. </p>

</div>
</div>
<a class="anchor" id="a5418f9715ac264bedaf2719f0e6826f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classcg_u_i_d.html">cgUID</a>&amp; cgScene::getReferenceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classcg_reference.html#a2d82a999b1c74fc4517bc41567bb4b53">cgReference</a>.</p>

</div>
</div>
<a class="anchor" id="acabda8988b0896dcdc186a68aa3f2974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> cgScene::getRenderClassId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_string.html">cgString</a> &amp;&#160;</td>
          <td class="paramname"><em>className</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the integer identifier associated with the specified user defined render class name string. </p>

</div>
</div>
<a class="anchor" id="ab896b542acd9c109dc8e9ff65ccad376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_render_driver.html">cgRenderDriver</a> * cgScene::getRenderDriver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply retrieve the render driver through which the scene will be rendered. </p>

</div>
</div>
<a class="anchor" id="a0c8ab019b6a6ed3426a812074e9b785d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_resource_manager.html">cgResourceManager</a> * cgScene::getResourceManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply retrieve the resource manager that will manage the scene's resources. </p>

</div>
</div>
<a class="anchor" id="a87f3f22becb17a225bb4ab754d33139d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cgObjectNodeMap &amp; cgScene::getRootObjectNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a list of all scene object nodes that exist at the root level of the node hierarchy (those with no parent node). </p>

</div>
</div>
<a class="anchor" id="a92c271ab15294ccb8f6252505df20725"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cgObjectNodeMap &amp; cgScene::getRootObjectNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a list of all scene object nodes that exist at the root level of the node hierarchy (those with no parent node). </p>

</div>
</div>
<a class="anchor" id="ade1fdd6fc3b7f67dba5d5c85ca8e72a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cgSceneCellMap &amp; cgScene::getSceneCells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a complete list of all allocated scene cells. </p>

</div>
</div>
<a class="anchor" id="a2d11f2b42df9f7ba230ccee05c8b87ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcg_scene_descriptor.html">cgSceneDescriptor</a> * cgScene::getSceneDescriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the full descriptor for the scene. </p>

</div>
</div>
<a class="anchor" id="a801c32dfd1ba671339893cf4e0a782fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cgSceneElementArray &amp; cgScene::getSceneElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a complete list of all allocated scene elements. </p>

</div>
</div>
<a class="anchor" id="abf533f4273b254968656d6176cb50f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cgSceneElementArray &amp; cgScene::getSceneElementsByType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a list of all allocated scene elements of the specified type. </p>

</div>
</div>
<a class="anchor" id="addd0ea4820b8c4f148350d4346f68a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a> cgScene::getSceneId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the unique integer identifier associated with this scene. </p>

</div>
</div>
<a class="anchor" id="a175ba8eb8dd86b2eae5e4a531be1a423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cgScene::SceneMaterialMap &amp; cgScene::getSceneMaterials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the list of all active materials associated with this scene. </p>

</div>
</div>
<a class="anchor" id="ad13faaf586002dccfdfcbf5f736a3e02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_sphere_tree.html">cgSphereTree</a> * cgScene::getSceneTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the scene's spatial hierarchy data, most commonly used for broadphase tests. </p>

</div>
</div>
<a class="anchor" id="a52dbca6b7060acce84d664f2d5e69ecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::getSelectedAABB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_bounding_box.html">cgBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a>&#160;</td>
          <td class="paramname"><em>growAmount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a world space axis aligned bounding box for each of the currently selected nodes. </p>

</div>
</div>
<a class="anchor" id="a3e3f3d1e455e0497b348234f7d33b5df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cgObjectNodeMap &amp; cgScene::getSelectedNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a list of the currently selected nodes. </p>

</div>
</div>
<a class="anchor" id="a31985e0978c58fcebba9791256b4ffb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cgObjectNodeMap &amp; cgScene::getSelectedNodesOrdered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a list of the currently selected nodes in the order in which they were selected. </p>

</div>
</div>
<a class="anchor" id="a739c9a4d81c38dd4ce9803288f9ade39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::getSelectedPivot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pivotOut</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a world space point about which selected nodes should pivot during rotation for instance. If one node is select, this will be its origin, otherwise it will be the average of all selected node origins. </p>

</div>
</div>
<a class="anchor" id="a864397ec7e0d1050c9a8e39dab3888d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cgScene::SelectionSetMap &amp; cgScene::getSelectionSets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a list of the currently available selection sets. </p>

</div>
</div>
<a class="anchor" id="a5f721784e6b3154d98d634de47e39331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_group_node.html">cgGroupNode</a> * cgScene::groupObjectNodes </td>
          <td>(</td>
          <td class="paramtype">cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asActor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Group together the specified nodes into either a standard collection group, or optionally as an actor. </p>

</div>
</div>
<a class="anchor" id="a312182cd0c701e77feb7619b5fb78c0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::groupSelected </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asActor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Group together any currently selected nodes into either a standard collection group, or optionally as an actor. </p>

</div>
</div>
<a class="anchor" id="ab3a0873d5c3079496058c4e73da995a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_landscape.html">cgLandscape</a> * cgScene::importLandscape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcg_landscape_import_params.html">cgLandscapeImportParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a new scene landscape based on the import parameters specified. </p>

</div>
</div>
<a class="anchor" id="a09ea869e2896bf617ddea3b8ac90ba3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::isActiveMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_material.html">cgMaterial</a> *&#160;</td>
          <td class="paramname"><em>material</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified material is one of this scene's active materials (those that should show up in the material editor). </p>

</div>
</div>
<a class="anchor" id="a5f49cf15c31ce73f18e0bec3ca3a0a7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::isDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the scene dirty status.</p>

</div>
</div>
<a class="anchor" id="a0d56d8312480d84f6c12ffdf731cc7fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::isDynamicsEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the state which determines whether scene dynamics processing (physics updates) are currently enabled. </p>

</div>
</div>
<a class="anchor" id="afe2ea334fd5172476f520ad11e063941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::isEventSuppressionEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether or not standard scene events are currently being suppressed. </p>

</div>
</div>
<a class="anchor" id="a81d04893e47c784c349913754a1a203c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::isLoading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the scene is currently in the process of loading. </p>

</div>
</div>
<a class="anchor" id="af73b5a3470cc9d76c0704ef375f3526d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::isSceneWritingEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Are nodes allowed to serialize their transformation updates to the scene database? </p>

</div>
</div>
<a class="anchor" id="ad5a7f0d42d0e657229141cb6a2f62e9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::isUpdating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the scene currently within its main update process? </p>

</div>
</div>
<a class="anchor" id="a9760ffe743dfd688ed75a85bd5fe5fa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::isUpdatingEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the state which determines whether scene objects will automatically receive calls to their 'update' method during scene update processing. </p>

</div>
</div>
<a class="anchor" id="acfc6854e89d05e9536685e2a983ce607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::load </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the scene and begin the loading process.</p>
<p>The scene that will be loaded is based on the information provided within the <a class="el" href="classcg_scene_descriptor.html" title="Contains all of the information that describes how a scene is constructed, and maintains this informa...">cgSceneDescriptor</a> object instance passed to the scene class constructor. </p>
<p>This method cannot be called directly. Instead, the application should load a new scene via the <a class="el" href="classcg_world.html#ae37a93aaef23fd833508537f7cce0b12" title="Allocate and load the specified scene by identifier. This will activate a scene such that all require...">cgWorld::loadScene()</a> method.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcg_scene.html#a3acdeafba075b1d94714c840f3373518" title="Class constructor.">cgScene()</a>, <a class="el" href="classcg_world.html#ae37a93aaef23fd833508537f7cce0b12" title="Allocate and load the specified scene by identifier. This will activate a scene such that all require...">cgWorld::loadScene()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a35b2f556e101ef5b776a086d557f8c79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::loadAllCells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the scene data from the world database. </p>

</div>
</div>
<a class="anchor" id="a37d0cf8ea3fa3eb7e309e50299a9568d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_object_node.html">cgObjectNode</a> * cgScene::loadObjectNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td>
          <td class="paramname"><em>referenceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a>&#160;</td>
          <td class="paramname"><em>cloneMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loadChildren</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recreate a previously existing node, loading it from the database based on the specified reference identifier. The node did not originally have to belong to this scene, and can optionally be cloned into a new node (with a new internal identifier) if required. This is essentially the primary method by which the application 'spawn in' new entities. </p>

</div>
</div>
<a class="anchor" id="a86806123bf91a8b4c47c01963182d6df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_object_node.html">cgObjectNode</a> * cgScene::loadObjectNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td>
          <td class="paramname"><em>rootReferenceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td>
          <td class="paramname"><em>referenceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcg_world_query.html">cgWorldQuery</a> *&#160;</td>
          <td class="paramname"><em>nodeData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecg_clone_method.html#a9c3d9d845b3fb56c57f151799de5b4fe">cgCloneMethod::Base</a>&#160;</td>
          <td class="paramname"><em>cloneMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcg_scene_cell.html">cgSceneCell</a> *&#160;</td>
          <td class="paramname"><em>parentCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>parentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>loadedNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loadChildren</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recreate a previously existing node, loading it from the database based on the specified data query. Can also recurse through any available child hierarchy on request. </p>

</div>
</div>
<a class="anchor" id="a819fed469f5500f3621a3329e4ebe34d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::loadSceneElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the scene element data from the world database. </p>

</div>
</div>
<a class="anchor" id="a0a62add9c8f46aaab2d2cc9b5fa54b51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_string.html">cgString</a> cgScene::makeUniqueName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_string.html">cgString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the specified suggested name, determine if it is unique. If it is not unique, append a number to the end such that it will become unique. </p>

</div>
</div>
<a class="anchor" id="a7dc7fb1cf207aa60b2c3b89c40074265"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_string.html">cgString</a> cgScene::makeUniqueName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_string.html">cgString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td>
          <td class="paramname"><em>suffixNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the specified suggested name, determine if it is unique. If it is not unique, append a number to the end such that it will become unique. Note: Specify 0xFFFFFFFF to suffixNumber to initially search for name with no appended number. </p>

</div>
</div>
<a class="anchor" id="a40061b7038694c2422ecfdfe7044adf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onDeleteSelection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_scene_event_args.html">cgSceneEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a22169d211e9567616a6afb0492a0f8f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onMaterialAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_scene_material_event_args.html">cgSceneMaterialEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a7f2993f8a7700861e13be7d0184ec67f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onMaterialRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_scene_material_event_args.html">cgSceneMaterialEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a8218f757afe601cb9c0c70ef24933df3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onModifySelection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_scene_event_args.html">cgSceneEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="af36567ab4220d274815bd6bb9efb2ed1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onNodeAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_node_updated_event_args.html">cgNodeUpdatedEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a72e61613c09d3c6e9e892fabc7489de6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onNodeDeleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_node_updated_event_args.html">cgNodeUpdatedEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a52b445622d3e81fb54ac5f5afc0503e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onNodeNameChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_node_updated_event_args.html">cgNodeUpdatedEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a89a918f39364b1a2cb51266d9536c8c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onNodeParentChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_node_parent_change_event_args.html">cgNodeParentChangeEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a218ea8e361f24b87f634740f9111ca84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onNodesDeleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_nodes_updated_event_args.html">cgNodesUpdatedEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overridden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="abf7bbe87fdac2901fee2417585fa757a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onPhysicsStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_physics_world.html">cgPhysicsWorld</a> *&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcg_physics_world_step_event_args.html">cgPhysicsWorldStepEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event triggered each time the physics world steps for a single iteration. </p>

<p>Reimplemented from <a class="el" href="classcg_physics_world_event_listener.html#ae3e9557535d035b99d3b66e2c3a64f43">cgPhysicsWorldEventListener</a>.</p>

</div>
</div>
<a class="anchor" id="a3188f9e3e340c396ce077626691b963f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onSceneDirtyChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_scene_event_args.html">cgSceneEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a9f58be73de6fd333b4af3c457f6db5c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onSceneElementAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_scene_element_event_args.html">cgSceneElementEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a90603475755912b322ad430182d61400"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onSceneElementDeleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_scene_element_event_args.html">cgSceneElementEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a9b12555860991525aa4054836a2bd211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onSceneLoadProgress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_scene_load_progress_event_args.html">cgSceneLoadProgressEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="a2b1ce0bc147edc3203766e1eb92f58b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onSelectionCleared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_scene_event_args.html">cgSceneEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="ae5ca8ade5ff06b2ea5dcc0738931b888"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onSelectionSetAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_selection_set_event_args.html">cgSelectionSetEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="acd6e68eb0d70e989f228ae11b1867cc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onSelectionSetRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_selection_set_event_args.html">cgSelectionSetEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="ad625a12f19f0c5f296d47f36d714c835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::onSelectionUpdated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcg_selection_updated_event_args.html">cgSelectionUpdatedEventArgs</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be overriden or called by derived class in order to trigger the event with matching name. All listeners will subsequently be notified. </p>

</div>
</div>
<a class="anchor" id="aaa89de64c240ccf99b61b642ae037c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::openSelectedGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open any currently selected groups such that their child nodes become available for selection / editing as if they were detached. </p>

</div>
</div>
<a class="anchor" id="a6b28bfcb67a4123a5b4844e5417a2819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_object_node.html">cgObjectNode</a> * cgScene::pickClosestNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcg_size.html">cgSize</a> &amp;&#160;</td>
          <td class="paramname"><em>viewportSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rayOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rayDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>intersectionOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the specified ray, find the closest node that is intersected by that ray and return it. Also return the intersection point on the node. </p>

</div>
</div>
<a class="anchor" id="a65bfb7695401ec01e55ec69f44223c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_object_node.html">cgObjectNode</a> * cgScene::pickClosestNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcg_size.html">cgSize</a> &amp;&#160;</td>
          <td class="paramname"><em>viewportSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rayOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rayDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a>&#160;</td>
          <td class="paramname"><em>wireTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>intersectionOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the specified ray, find the closest node that is intersected by that ray and return it. Also return the intersection point on the node. </p>

</div>
</div>
<a class="anchor" id="a497b6dbfa4d0d54aeaa900ddaa6590dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::prepareQueries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare any cached world queries as necessary. </p>

</div>
</div>
<a class="anchor" id="ac295103b2d5d7e49bb39352e9416435d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::processMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_message.html">cgMessage</a> *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process any messages sent to us from other objects, or other parts of the system via the reference messaging system (<a class="el" href="classcg_reference.html" title="Base class which provides standardized reference counting behaviors in addition to recording informat...">cgReference</a>). </p>

<p>Reimplemented from <a class="el" href="classcg_reference.html#a2c78842232c529fe509dedebb1cecf6b">cgReference</a>.</p>

</div>
</div>
<a class="anchor" id="a499a1d7174f41899f2b24fb62b4f471a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::queryReferenceType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the application to determine if the inheritance hierarchy supports a particular interface. </p>

<p>Implements <a class="el" href="classcg_reference.html#a597d24d0d03d4cf61e2afcd842a43fa4">cgReference</a>.</p>

</div>
</div>
<a class="anchor" id="aa54470b68bfc3b6ec091e2fda7cbd38d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::queueNodeUpdates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called internally when an object node has been updated in order to queue that node for additional processing in cases where certain update processes need to be deferred until a later time. An example might be the deferral of child transform updates until all nodes in a hierarchy have been processed (such as during the animation of a character's full bone hierarchy). </p>

</div>
</div>
<a class="anchor" id="a202dbb83e8ff3cecfd704e6dba72e320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::rayCastAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sortContacts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cgSceneRayCastContact::Array &amp;&#160;</td>
          <td class="paramname"><em>contacts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a list of all intersected collidable scene objects along the specified ray. The list of contacts can optionally be sorted by distance with the closest intersection first. </p>

</div>
</div>
<a class="anchor" id="a25a2d1f3b2631b55a500afac1c8c8786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::rayCastClosest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcg_scene_ray_cast_contact.html">cgSceneRayCastContact</a> &amp;&#160;</td>
          <td class="paramname"><em>closestContact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the closest intersected collidable scene objects along the specified ray. </p>

</div>
</div>
<a class="anchor" id="a3f9a3d73c1a413b5227f19e6b9828036"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a> cgScene::rayCastClosestFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_physics_body.html">cgPhysicsBody</a> *&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_vector3.html">cgVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>hitNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#a56025923e37960cbd26905608b2f0d06">cgInt</a>&#160;</td>
          <td class="paramname"><em>collisionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#ac3b2f4169377d4d32e6c8b62a6b4e68a">cgFloat</a>&#160;</td>
          <td class="paramname"><em>intersectParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function that will be called by the physics system each time a new collidable body is actually hit during narrow phase calculations. </p>

</div>
</div>
<a class="anchor" id="ac601b64a8a5ec87c9c5c7a2b03c6237a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::rayCastPreFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_physics_body.html">cgPhysicsBody</a> *&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcg_physics_shape.html">cgPhysicsShape</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function that will be called by the physics system each time a new collidable body is discovered during broad phase calculations. We can use this to strip away bodies that are of no interest to us early. </p>

</div>
</div>
<a class="anchor" id="ae5193f6e7b6385274925d5a79be4a6fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::reload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unload and then immediately reload the scene data.</p>

</div>
</div>
<a class="anchor" id="acacf3780d4622a7a9f6ed5a6abc29d52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::reloadRenderControl </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reloadScript</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reload and re-initialize the render control script and the instantitated script object. </p>

</div>
</div>
<a class="anchor" id="a54d24a80fa301753b0c93b91f8211a58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::removeRootNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the specified node from the scene's root node list. </p>

</div>
</div>
<a class="anchor" id="a33d01508b8954380cf0fbe13567ad263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::removeSceneMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_material.html">cgMaterial</a> *&#160;</td>
          <td class="paramname"><em>material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the specified material from the scene's material ownership list. If the scene was the last live item reference that material, and if it held the last 'soft' reference it will be deleted from the database. </p>

</div>
</div>
<a class="anchor" id="a54b7fa8ddf02fb1075b87b8e67afcc03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::removeSelectionSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_string.html">cgString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a previously created selection set. </p>

</div>
</div>
<a class="anchor" id="a17516470b52a88a54e155be0d2843d3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::render </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the scene to perform the rendering of an individual scene. </p>

</div>
</div>
<a class="anchor" id="a19f2ac96b8c8dda25081549c68c5547b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::resetScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reload the transforms and cell ownership information for the nodes in the scene as they exist in the current scene database. </p>

</div>
</div>
<a class="anchor" id="ae01e9a9ee1e67d118f8574ca0746bb20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::resetSelectedOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the orientation transforms of all selected nodes. </p>

</div>
</div>
<a class="anchor" id="a66f5b138d8e030de31631cc6b04e9011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::resetSelectedPivot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the pivot point of all selected nodes. </p>

</div>
</div>
<a class="anchor" id="adf3ce3478a767dd7378669e0a4da0ce4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::resetSelectedScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the scale transforms of all selected nodes. </p>

</div>
</div>
<a class="anchor" id="ae50de8701184c05339e365df634ce5d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::resolvedNodeUpdates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specified node's pending updates have been resolved and it can be removed from the pending update set. </p>

</div>
</div>
<a class="anchor" id="a78a82dade080c4680cbfc6db5bc8d575"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::resolvePendingUpdates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all pending node updates that opted to defer the computation of certain information until the entire update process was complete. </p>

</div>
</div>
<a class="anchor" id="a3beb59028aacb4852f9ca2f0476df16d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::sandboxRender </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cg_base_types_8h.html#a89e22fa63a03e79f51d5c795bb9f9f44">cgUInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcg_plane.html">cgPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>gridPlane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow all nodes to render their 'sandbox' representation &ndash; that is the representation to be displayed within an editing environment. </p>

</div>
</div>
<a class="anchor" id="a6bec20e6859a81e705fcbb78fc2bef00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::selectAllNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply select all nodes contained in the currently open scene. </p>

</div>
</div>
<a class="anchor" id="a20f065763bacded09a41417623839aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::selectNodes </td>
          <td>(</td>
          <td class="paramtype">cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceSelection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select a specific collection of nodes. </p>

</div>
</div>
<a class="anchor" id="a0a5d24ce9737158f246eec0562d802ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::selectSimilarNodes </td>
          <td>(</td>
          <td class="paramtype">cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceSelection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select nodes that have types similar to the nodes specified. </p>

</div>
</div>
<a class="anchor" id="a80a5a4376009f481390ab72019b0f7b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::setActiveCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_camera_node.html">cgCameraNode</a> *&#160;</td>
          <td class="paramname"><em>pCamera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the currently active camera. </p>

</div>
</div>
<a class="anchor" id="a0b3dd67c77a2328b10260c91fedbfc6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::setActiveObjectElementType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcg_u_i_d.html">cgUID</a> &amp;&#160;</td>
          <td class="paramname"><em>typeIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sandbox environment is manipulating the specified element type (i.e. object sub-element category). This property can be queried by objects and other scene elements to determine if they should be considered the 'active' element type. Set to '<a class="el" href="classcg_u_i_d.html#ae0bb84d8bdcdfad56e2d42ea7693a8c7">cgUID::Empty</a>' to disable this. </p>

</div>
</div>
<a class="anchor" id="ac9fb003ab02b4a096be22f837632150d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::setDirty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dirty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the scene dirty status.</p>

</div>
</div>
<a class="anchor" id="a8ff39fa2da00c0ed422645541bfa94b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::setObjectUpdateRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecg_update_rate.html#a0da2807d89bc281aaedc56c1edbdbd24">cgUpdateRate::Base</a>&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each update list has a different rate that can be used in order to reduce the amount of nodes which potentially have to be updated each frame. This function simply adds the node to the relevant internal update list based on the specified rate. </p>

</div>
</div>
<a class="anchor" id="a215fc59e2b9a255d6fdc9c7197717e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::suppressEvents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suppress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this method to enable or disable the dispatching of events that normally takes place when actions are performed on the scene such as creating or deleting objects, adding scene elements, etc. All events supported by '<a class="el" href="classcg_scene_event_listener.html" title="Abstract interface class from which other classes can derive in order to recieve messages whenever sc...">cgSceneEventListener</a>' will be suppressed when enabled. </p>

</div>
</div>
<a class="anchor" id="a31c83fc57c62ead2f0651e1cd2eca4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::ungroupSelected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ungroup any currently selected groups. </p>

</div>
</div>
<a class="anchor" id="ad97c8f36abd93191312fae0db1fa27e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::unload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unload this scene from the parent manager with a convenient method. </p>

</div>
</div>
<a class="anchor" id="a6c6ce25b0fb23fc2b11ceb309469387d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::unloadObjectNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call in order to remove the specified node from the in-memory scene but /not/ from the scene database. </p>

</div>
</div>
<a class="anchor" id="a71fa0e8a5b59886e64b41b9422d72a7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::unloadObjectNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unloadChildren</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call in order to remove the specified node from the in-memory scene but /not/ from the scene database. </p>

</div>
</div>
<a class="anchor" id="a2a049b7080740f6fa8d64c2f039de070"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::unloadObjectNodes </td>
          <td>(</td>
          <td class="paramtype">cgObjectNodeMap &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call in order to remove a whole list of nodes from the in-memory scene in one go, but /not/ from the scene database. </p>

</div>
</div>
<a class="anchor" id="a2ee1cad5d922ade8be2cf5df2f9009cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::unloadSceneElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_scene_element.html">cgSceneElement</a> *&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call in order to remove the scene element from the in-memory scene but /not/ from the scene database. </p>

</div>
</div>
<a class="anchor" id="a87e8738cf21d7fa8b3c0a3c3d6d9d0f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the scene to perform its update pass prior to rendering. </p>

</div>
</div>
<a class="anchor" id="a361cf32b0911e3dcc24fc20c9e7d2cc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgScene::updateObjectOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcg_object_node.html">cgObjectNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the various spatial (and scene) tree components to determine if it can / wants to own the specified object and optionally inserts it into the relevant cells / leaves. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ade248d285eb9af2263a1e72a0eb4e7f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_camera_node.html">cgCameraNode</a>* cgScene::mActiveCamera</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab9f3367cdf5f6eff5bfbbb7532689cde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SceneMaterialMap cgScene::mActiveMaterials</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2510238df3215a112a6f3e895c372546"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_u_i_d.html">cgUID</a> cgScene::mActiveObjectElementType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3be9779fddf78b25ebce8d8e2dbd551f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cgSceneCellMap cgScene::mCells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a03c4134f0e122112437432d9ac265867"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_world_query.html">cgWorldQuery</a> cgScene::mDeleteElementUsage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ec32b7b61c298859a39774166161fef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_world_query.html">cgWorldQuery</a> cgScene::mDeleteMaterialUsage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7ced48c728b77ca9545e3f147f2f53b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::mDynamicsEnabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa310ecfa8623fcca25e20b75f110eddc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cgSceneElementArray cgScene::mElements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afe46dc022cb4ca692777fca46f37f2df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SceneElementTypeMap cgScene::mElementTypes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8d2ce0e08fdcc1f21a16fde28be23ddf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_world_query.html">cgWorldQuery</a> cgScene::mInsertElementUsage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d65ed44b1d79e0d1044c8ba7daf1b20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_world_query.html">cgWorldQuery</a> cgScene::mInsertMaterialUsage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3024ef72cabb67af419222dd6ed2b67c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::mIsDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6b14623acbe6998dfee2789c06d16a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::mIsLoading</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7296b19f0fe364380473a9c38bf31f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::mIsUpdating</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0148efe752a0922e10ddd3f3d3b55920"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_landscape.html">cgLandscape</a>* cgScene::mLandscape</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b53034068cf8871976e1fe4952d5af9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_lighting_manager.html">cgLightingManager</a>* cgScene::mLightingManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2a8e7c3f8e374251645e0e4eef28e017"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_world_query.html">cgWorldQuery</a> cgScene::mLoadChildObjectNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af2ed598c94d292896026db7d68493923"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_world_query.html">cgWorldQuery</a> cgScene::mLoadObjectNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e6bba9d3e8bfb4a4c1908a01dbda4a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NameUsageMap cgScene::mNameUsage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ace5218d8ada5ef289bc5dfc695032ad1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cg_base_types_8h.html#a97b16012f7c42f34ea3a09e09da20d26">cgInt32</a> cgScene::mNextSelectionId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a945ecf804902e4ec226e638be2249196"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cgObjectNodeMap cgScene::mObjectNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af0de9779dc95e26e9bb45ec73d51ab33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectNodeTypeMap cgScene::mObjectNodeTypes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34e525f99cde6525aed7869556e21c97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cgScriptArgument::Array cgScene::mOnSceneRenderArgs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa65f7c511d39986347a49de695a00398"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cg_script_interop_8h.html#a70afeb5f6d7ee30b8817ed7de4d31a85">cgScriptFunctionHandle</a> cgScene::mOnSceneRenderMethod</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ff1522f4f35246fa698f9aafb6e0506"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VisibilitySetArray cgScene::mOrphanVisSets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12b740bd5356fb48e14e083d7dfbac03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::mPassBegun</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7431b61dd65515bdc3ed905b0ee1f45c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_scene_update_f_i_f_o.html">cgSceneUpdateFIFO</a> cgScene::mPendingUpdateFIFO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abca7dbb3830fdadf2f028a5f072627f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_physics_world.html">cgPhysicsWorld</a>* cgScene::mPhysicsWorld</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0aac8376260cc801c21a9e41d73192f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cg_resource_handles_8h.html#a118acf0914cb9c76815e189ac6f8a0c0">cgScriptHandle</a> cgScene::mRenderScript</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8976236553bdf9e5715d2da951b916f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cgObjectNodeMap cgScene::mRootNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add3ba268c26c0e416910aa42d555ed2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ControllerArray cgScene::mSceneControllers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a24c4cd5a7ab7df9eb87a97f9d59f3997"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_scene_descriptor.html">cgSceneDescriptor</a> cgScene::mSceneDescriptor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a64c3d4312b142d790ed0486a0dd54648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_sphere_tree.html">cgSphereTree</a>* cgScene::mSceneTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e726f24f3070348b2c2768ac568c65e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::mSceneWritesEnabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa680b7ec9f341e5df707a6dacca2b721"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_script_object.html">cgScriptObject</a>* cgScene::mScriptObject</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aefe256c4ac49f8d6ed354fef417eb435"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cgObjectNodeMap cgScene::mSelectedNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ade594b889435994ba5ffee4756dd2a30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cgObjectNodeMap cgScene::mSelectedNodesOrdered</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4bf8d3844064856af2c8fac032af1b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SelectionSetMap cgScene::mSelectionSets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b6d0906085dfd4e2870cc0fa2612ce8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_b_s_p_tree.html">cgBSPTree</a>* cgScene::mStaticVisTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84cd9df9242529ed70035471dab2fb0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::mSuppressEvents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a35761b94855d3f380c0dad6ecc0b844f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcg_scene_1_1_update_bucket.html">UpdateBucket</a> cgScene::mUpdateBuckets[<a class="el" href="namespacecg_update_rate.html#a0da2807d89bc281aaedc56c1edbdbd24a6c956cd08c69a8f3574b5757eb101898">cgUpdateRate::Count</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1806f2ddf76f4cfc0609207ef618f101"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cgScene::mUpdatingEnabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a53f1439e8d86481e6b5e03ba56d5a0df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcg_world.html">cgWorld</a>* cgScene::mWorld</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="cg_scene_8h_source.html">cgScene.h</a></li>
<li><a class="el" href="cg_scene_8cpp.html">cgScene.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classcg_scene.html">cgScene</a></li>
    <li class="footer">Generated on Mon May 12 2014 08:23:40 for Carbon Game Development Toolkit by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
